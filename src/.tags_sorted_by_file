!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
check_surf_bind	backup/fetm_140328.c	/^float check_surf_bind (int current_material_index, int proj_Z) {$/;"	f
check_target_type_fetm	backup/fetm_140328.c	/^int check_target_type_fetm (float x, float y, float z, float vx, float vy, float vz,$/;"	f
freepath_fetm	backup/fetm_140328.c	/^int freepath_fetm (float *x, float *y, float *z, float *vx, float *vy, float *vz,$/;"	f
juintersect	backup/fetm_140328.c	/^int juintersect (float x, float y, float z, float vx, float vy,$/;"	f
make_line	backup/fetm_140328.c	/^int make_line (int *line_flag, float x, float y, float z, float vx, float vy, float vz,$/;"	f
read_fetm_shape	backup/fetm_140328.c	/^int read_fetm_shape (char *file_name) {$/;"	f
refraction	backup/fetm_140328.c	/^void refraction (double NT[], float *vx, float *vy, float *vz, int *SFlag,$/;"	f
transmission	backup/fetm_140328.c	/^void transmission (double uz, int idied, float energy, float U0) {$/;"	f
triangle_intersect_fetm	backup/fetm_140328.c	/^int triangle_intersect_fetm (float trix1, float triy1, float triz1, float trix2,$/;"	f
FETM_H	backup/fetm_140328.h	13;"	d
GBOX	backup/fetm_140328.h	/^    float GBOX[100][9];$/;"	m	struct:GRIDBOX
GRB	backup/fetm_140328.h	/^struct GRIDBOX ***GRB;$/;"	v	typeref:struct:GRIDBOX
GRIDBOX	backup/fetm_140328.h	/^struct GRIDBOX  \/*  *\/$/;"	s
ax	backup/fetm_140328.h	/^float ax, ay, az;  \/*  *\/$/;"	v
ay	backup/fetm_140328.h	/^float ax, ay, az;  \/*  *\/$/;"	v
az	backup/fetm_140328.h	/^float ax, ay, az;  \/*  *\/$/;"	v
box_count_x	backup/fetm_140328.h	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_count_y	backup/fetm_140328.h	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_count_z	backup/fetm_140328.h	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_size_x	backup/fetm_140328.h	/^float box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_size_y	backup/fetm_140328.h	/^float box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_size_z	backup/fetm_140328.h	/^float box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
di	backup/fetm_140328.h	/^int   di, dj, dk;  \/*  *\/$/;"	v
dj	backup/fetm_140328.h	/^int   di, dj, dk;  \/*  *\/$/;"	v
dk	backup/fetm_140328.h	/^int   di, dj, dk;  \/*  *\/$/;"	v
in_or_not	backup/fetm_140328.h	/^int   in_or_not;$/;"	v
mater_type	backup/fetm_140328.h	/^    int mater_type[100];$/;"	m	struct:GRIDBOX
num_triangles	backup/fetm_140328.h	/^    int num_triangles;$/;"	m	struct:GRIDBOX
rx	backup/fetm_140328.h	/^float rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
ry	backup/fetm_140328.h	/^float rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
rz	backup/fetm_140328.h	/^float rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
check_material_type	backup/fetm_140414.c	/^void check_material_type (int *in_or_not, double x, double y, double z, int proj_Z,$/;"	f
check_surf_bind	backup/fetm_140414.c	/^float check_surf_bind (int current_material_index, int proj_Z) {$/;"	f
check_target_type_fetm	backup/fetm_140414.c	/^int check_target_type_fetm (double x, double y, double z, double vx, double vy, double vz,$/;"	f
freepath_fetm	backup/fetm_140414.c	/^int freepath_fetm (double *x, double *y, double *z, double *vx, double *vy, double *vz,$/;"	f
juintersect	backup/fetm_140414.c	/^int juintersect (double *x, double *y, double *z, double vx, double vy, double vz) {$/;"	f
make_line	backup/fetm_140414.c	/^int make_line (double x, double y, double z, double vx,$/;"	f
read_fetm_shape	backup/fetm_140414.c	/^int read_fetm_shape (char *file_name) {$/;"	f
refraction	backup/fetm_140414.c	/^void refraction (double NT[], double *vx, double *vy, double *vz, int *S_flag,$/;"	f
transmission	backup/fetm_140414.c	/^void transmission (double uz, int idied, float energy, float U0) {$/;"	f
triangle_intersect_fetm	backup/fetm_140414.c	/^int triangle_intersect_fetm (double trix1, double triy1, double triz1, double trix2,$/;"	f
mpi_distribute	backup/mpimod.c	/^void mpi_distribute () {$/;"	f
mpi_init	backup/mpimod.c	/^int mpi_init () {$/;"	f
mpi_oprate	backup/mpimod.c	/^void mpi_oprate (int type) {$/;"	f
mpi_trans_data	backup/mpimod.c	/^int mpi_trans_data () {$/;"	f
MPIMOD_H	backup/mpimod.h	13;"	d
ierr	backup/mpimod.h	/^int ierr;$/;"	v
my_node	backup/mpimod.h	/^int my_node, num_nodes;$/;"	v
n_ion	backup/mpimod.h	/^int n_ion_id, n_ion, num_part;$/;"	v
n_ion_id	backup/mpimod.h	/^int n_ion_id, n_ion, num_part;$/;"	v
num_nodes	backup/mpimod.h	/^int my_node, num_nodes;$/;"	v
num_part	backup/mpimod.h	/^int n_ion_id, n_ion, num_part;$/;"	v
over_node	backup/mpimod.h	/^int *over_node, *status;$/;"	v
send_recv_double_data	backup/mpimod.h	/^double *send_recv_double_data;$/;"	v
send_recv_int_data	backup/mpimod.h	/^int *send_recv_int_data;$/;"	v
send_recv_ion_id	backup/mpimod.h	/^int send_recv_ion_id;$/;"	v
status	backup/mpimod.h	/^int *over_node, *status;$/;"	v
mpi_distribute	backup/mpimod2.c	/^void mpi_distribute () {$/;"	f
mpi_init	backup/mpimod2.c	/^int mpi_init () {$/;"	f
mpi_reduce_data	backup/mpimod2.c	/^int mpi_reduce_data () {$/;"	f
calc_surface_normal	backup/transport_140312.c	/^int calc_surface_normal (int old_cell, int new_cell, float *nx, float *ny, float *nz) {$/;"	f
check_and_correct_boundary	backup/transport_140312.c	/^int check_and_correct_boundary (float *dim, float target_size, float *target_size_max, int boundary) {$/;"	f
coll_c	backup/transport_140312.c	/^int coll_c;             \/* collide *\/$/;"	v
def_ion_enetry_pos	backup/transport_140312.c	/^void def_ion_enetry_pos (float *x, float *y, float *z) {$/;"	f
disp_c	backup/transport_140312.c	/^int disp_c;             \/* dispalcement *\/$/;"	v
electronic_stopping	backup/transport_140312.c	/^float electronic_stopping (int ionZ, float ionM, float ionE, int material) {$/;"	f
electronic_straggling	backup/transport_140312.c	/^float electronic_straggling (int ionZ, float ionM, float ionE, int material) {$/;"	f
escape_solid_c	backup/transport_140312.c	/^int escape_solid_c;     \/* *\/$/;"	v
fast_projectile_transport	backup/transport_140312.c	/^int fast_projectile_transport (int proj_Z, float proj_M, double proj_E, float proj_x,$/;"	f
full_projectile_transport	backup/transport_140312.c	/^int full_projectile_transport (int proj_Z, float proj_M, double proj_E, float proj_x,$/;"	f
int_c	backup/transport_140312.c	/^int int_c;              \/* interstitial *\/$/;"	v
ion_c	backup/transport_140312.c	/^int ion_c;              \/* ion *\/$/;"	v
irradiate_target	backup/transport_140312.c	/^int irradiate_target (void) {$/;"	f
leaving_ions_c	backup/transport_140312.c	/^int leaving_ions_c;     \/* *\/$/;"	v
leaving_recoils_c	backup/transport_140312.c	/^int leaving_recoils_c;  \/* *\/$/;"	v
miss_c	backup/transport_140312.c	/^int miss_c;             \/* missed collision *\/$/;"	v
refract_projectile2	backup/transport_140312.c	/^int refract_projectile2 (float *vx, float *vy, float *vz, float nx, float ny,$/;"	f
repl_c	backup/transport_140312.c	/^int repl_c;             \/* replacement *\/$/;"	v
rotate	backup/transport_140312.c	/^void rotate (float *l, float *m, float *n, unsigned int *iazim_angle,$/;"	f
single_ion_sputter_counter	backup/transport_140312.c	/^int single_ion_sputter_counter;$/;"	v
sputter_c	backup/transport_140312.c	/^int sputter_c;          \/* sputtering *\/$/;"	v
vac_c	backup/transport_140312.c	/^int vac_c;              \/* vacancy *\/$/;"	v
MAX_SPUTTERED	backup/transport_140312.h	122;"	d
TRANSPORT_H	backup/transport_140312.h	13;"	d
beam_spread	backup/transport_140312.h	/^float beam_spread;           \/* in nm, only relevant for option 3 *\/$/;"	v
chu_values	backup/transport_140312.h	/^float chu_values[98][4];    \/* Values to calculate straggling according to Chu's model;$/;"	v
detailed_sputtering	backup/transport_140312.h	/^int detailed_sputtering;  \/* Needs to be set to 1, if you want to get better results regarding$/;"	v
display_interval	backup/transport_140312.h	/^int    display_interval;        \/* display status every so many ions *\/$/;"	v
energy	backup/transport_140312.h	/^    float energy;            \/* exit energy *\/$/;"	m	struct:transmitted_ion
enter_x	backup/transport_140312.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_y	backup/transport_140312.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_z	backup/transport_140312.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
ion_M	backup/transport_140312.h	/^float ion_M;                  \/* mass of the ion *\/$/;"	v
ion_Z	backup/transport_140312.h	/^int   ion_Z;                  \/* proton number *\/$/;"	v
ion_distribution	backup/transport_140312.h	/^int   ion_distribution;      \/* 0 for random ion entry positions,$/;"	v
ion_initial_energy	backup/transport_140312.h	/^float ion_initial_energy;     \/* impinging energy *\/$/;"	v
ion_paths_fp	backup/transport_140312.h	/^FILE *ion_paths_fp;         \/* the file with the ion paths will be open all the time if the paths$/;"	v
ion_vx	backup/transport_140312.h	/^float ion_vx;                \/* vector of ion velocity, normalized to 1 *\/$/;"	v
ion_vy	backup/transport_140312.h	/^float ion_vy;                \/* Note, that the ion is NOT described by its actual velocity vector, *\/$/;"	v
ion_vz	backup/transport_140312.h	/^float ion_vz;                \/* but by the flying direction vector of length 1 and its energy. *\/$/;"	v
leaving_ions	backup/transport_140312.h	/^int leaving_ions[6];        \/* number of ions, leaving target in each direction, 6 -> 5, ygli *\/$/;"	v
max_annular_coll_volumes	backup/transport_140312.h	/^int max_annular_coll_volumes;  \/* According to W.Eckstein "Computer Simulation if Ion-Solid$/;"	v
max_no_ions	backup/transport_140312.h	/^int   max_no_ions;            \/* maximum number of ions *\/$/;"	v
min_energy	backup/transport_140312.h	/^float min_energy;            \/* minimum energy below which all projectiles are stopped *\/$/;"	v
override_energy	backup/transport_140312.h	/^double override_energy;         \/* for command-line argument override of ion energy *\/$/;"	v
override_max_ions	backup/transport_140312.h	/^int    override_max_ions;       \/* for command-line argument override of maximum number of ions *\/$/;"	v
recoil_cascades_fp	backup/transport_140312.h	/^FILE *recoil_cascades_fp;   \/* the file with the recoil cascades will be open all the time if the$/;"	v
scattering_calculation	backup/transport_140312.h	/^int scattering_calculation;     \/* 0: corteo database, 1: MAGIC  *\/$/;"	v
simulation_type	backup/transport_140312.h	/^int simulation_type;  \/* How to do the simulation.$/;"	v
single_ion_sputter_yields	backup/transport_140312.h	/^int single_ion_sputter_yields;  \/* if 1, iradina will store sputter yields for single ions$/;"	v
sputter_yield_histogram	backup/transport_140312.h	/^int *sputter_yield_histogram;   \/* array that stores single ion sputter yield histogram *\/$/;"	v
status_update_interval	backup/transport_140312.h	/^int    status_update_interval;  \/* After so many ions, the status is written to the status file$/;"	v
storage_interval	backup/transport_140312.h	/^int    storage_interval;        \/* dump the target arrays into the files every such number of ions *\/$/;"	v
store_energy_deposit	backup/transport_140312.h	/^int store_energy_deposit;  \/* if 1, array with deposited energy are created and stored;$/;"	v
store_exiting_limit	backup/transport_140312.h	/^int store_exiting_limit;     \/* maximum number of exiting recoils to be stored *\/$/;"	v
store_exiting_recoils	backup/transport_140312.h	/^int store_exiting_recoils;   \/* 1 if all exiting recoils should be stored *\/$/;"	v
store_ion_paths	backup/transport_140312.h	/^int store_ion_paths;  \/* 1 if the exact paths should be stored (interesting for debugging stuff *\/$/;"	v
store_path_limit	backup/transport_140312.h	/^int store_path_limit;        \/* only for so many ions, the exact paths and recoil cascades are stored *\/$/;"	v
store_recoil_cascades	backup/transport_140312.h	/^int store_recoil_cascades;  \/* 1 if the exact recoils cascades should be stored$/;"	v
store_transmitted_ions	backup/transport_140312.h	/^int store_transmitted_ions;  \/* 1 if true *\/$/;"	v
straggling_model	backup/transport_140312.h	/^int straggling_model;       \/* how to calc straggling *\/$/;"	v
transmission_pointer	backup/transport_140312.h	/^int transmission_pointer;    \/* point to next free index in array *\/$/;"	v
transmit_list	backup/transport_140312.h	/^struct transmitted_ion *transmit_list;  \/* list of transmitted ions *\/$/;"	v	typeref:struct:transmitted_ion
transmitted_ion	backup/transport_140312.h	/^struct transmitted_ion       \/* describes an ion that has been transmitted (left the target) *\/$/;"	s
transport_type	backup/transport_140312.h	/^int transport_type;             \/* 0: accurate, 1: Fast (like corteo) *\/$/;"	v
vx	backup/transport_140312.h	/^    float vx;                \/* exit velocity unit vector *\/$/;"	m	struct:transmitted_ion
vy	backup/transport_140312.h	/^    float vy;$/;"	m	struct:transmitted_ion
vz	backup/transport_140312.h	/^    float vz;$/;"	m	struct:transmitted_ion
x	backup/transport_140312.h	/^    float x;                 \/* exit position x *\/$/;"	m	struct:transmitted_ion
y	backup/transport_140312.h	/^    float y;                 \/* y *\/$/;"	m	struct:transmitted_ion
z	backup/transport_140312.h	/^    float z;                 \/* z *\/$/;"	m	struct:transmitted_ion
calc_surface_normal	backup/transport_140314.c	/^int calc_surface_normal (int old_cell, int new_cell, float *nx, float *ny, float *nz) {$/;"	f
check_and_correct_boundary	backup/transport_140314.c	/^int check_and_correct_boundary (float *dim, float target_size, float *target_size_max, int boundary) {$/;"	f
coll_c	backup/transport_140314.c	/^int coll_c;             \/* collide *\/$/;"	v
collision	backup/transport_140314.c	/^int collision (int proj_Z, float proj_M, int is_ion, float impact_par, float *energy,$/;"	f
def_ion_enetry_pos	backup/transport_140314.c	/^void def_ion_enetry_pos (float *x, float *y, float *z) {$/;"	f
disp_c	backup/transport_140314.c	/^int disp_c;             \/* dispalcement *\/$/;"	v
electronic_stopping	backup/transport_140314.c	/^float electronic_stopping (int ionZ, float ionM, float ionE, int material) {$/;"	f
electronic_straggling	backup/transport_140314.c	/^float electronic_straggling (int ionZ, float ionM, float ionE, int material) {$/;"	f
escape_solid_c	backup/transport_140314.c	/^int escape_solid_c;     \/* *\/$/;"	v
int_c	backup/transport_140314.c	/^int int_c;              \/* interstitial *\/$/;"	v
ion_c	backup/transport_140314.c	/^int ion_c;              \/* ion *\/$/;"	v
irradiate_target	backup/transport_140314.c	/^int irradiate_target (void) {$/;"	f
leaving_ions_c	backup/transport_140314.c	/^int leaving_ions_c;     \/* *\/$/;"	v
leaving_recoils_c	backup/transport_140314.c	/^int leaving_recoils_c;  \/* *\/$/;"	v
miss_c	backup/transport_140314.c	/^int miss_c;             \/* missed collision *\/$/;"	v
projectile_transport	backup/transport_140314.c	/^int projectile_transport (int proj_Z, float proj_M, double proj_E, float proj_x,$/;"	f
refract_projectile2	backup/transport_140314.c	/^int refract_projectile2 (float *vx, float *vy, float *vz, float nx, float ny,$/;"	f
repl_c	backup/transport_140314.c	/^int repl_c;             \/* replacement *\/$/;"	v
rotate	backup/transport_140314.c	/^void rotate (float *l, float *m, float *n, unsigned int *iazim_angle,$/;"	f
single_ion_sputter_counter	backup/transport_140314.c	/^int single_ion_sputter_counter;$/;"	v
sputter_c	backup/transport_140314.c	/^int sputter_c;          \/* sputtering *\/$/;"	v
vac_c	backup/transport_140314.c	/^int vac_c;              \/* vacancy *\/$/;"	v
MAX_SPUTTERED	backup/transport_140314.h	122;"	d
TRANSPORT_H	backup/transport_140314.h	13;"	d
beam_spread	backup/transport_140314.h	/^float beam_spread;           \/* in nm, only relevant for option 3 *\/$/;"	v
chu_values	backup/transport_140314.h	/^float chu_values[98][4];    \/* Values to calculate straggling according to Chu's model;$/;"	v
detailed_sputtering	backup/transport_140314.h	/^int detailed_sputtering;  \/* Needs to be set to 1, if you want to get better results regarding$/;"	v
display_interval	backup/transport_140314.h	/^int    display_interval;        \/* display status every so many ions *\/$/;"	v
energy	backup/transport_140314.h	/^    float energy;            \/* exit energy *\/$/;"	m	struct:transmitted_ion
enter_x	backup/transport_140314.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_y	backup/transport_140314.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_z	backup/transport_140314.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
ion_M	backup/transport_140314.h	/^float ion_M;                  \/* mass of the ion *\/$/;"	v
ion_Z	backup/transport_140314.h	/^int   ion_Z;                  \/* proton number *\/$/;"	v
ion_distribution	backup/transport_140314.h	/^int   ion_distribution;      \/* 0 for random ion entry positions,$/;"	v
ion_initial_energy	backup/transport_140314.h	/^float ion_initial_energy;     \/* impinging energy *\/$/;"	v
ion_paths_fp	backup/transport_140314.h	/^FILE *ion_paths_fp;         \/* the file with the ion paths will be open all the time if the paths$/;"	v
ion_vx	backup/transport_140314.h	/^float ion_vx;                \/* vector of ion velocity, normalized to 1 *\/$/;"	v
ion_vy	backup/transport_140314.h	/^float ion_vy;                \/* Note, that the ion is NOT described by its actual velocity vector, *\/$/;"	v
ion_vz	backup/transport_140314.h	/^float ion_vz;                \/* but by the flying direction vector of length 1 and its energy. *\/$/;"	v
leaving_ions	backup/transport_140314.h	/^int leaving_ions[6];        \/* number of ions, leaving target in each direction, 6 -> 5, ygli *\/$/;"	v
max_annular_coll_volumes	backup/transport_140314.h	/^int max_annular_coll_volumes;  \/* According to W.Eckstein "Computer Simulation if Ion-Solid$/;"	v
max_no_ions	backup/transport_140314.h	/^int   max_no_ions;            \/* maximum number of ions *\/$/;"	v
min_energy	backup/transport_140314.h	/^float min_energy;            \/* minimum energy below which all projectiles are stopped *\/$/;"	v
override_energy	backup/transport_140314.h	/^double override_energy;         \/* for command-line argument override of ion energy *\/$/;"	v
override_max_ions	backup/transport_140314.h	/^int    override_max_ions;       \/* for command-line argument override of maximum number of ions *\/$/;"	v
recoil_cascades_fp	backup/transport_140314.h	/^FILE *recoil_cascades_fp;   \/* the file with the recoil cascades will be open all the time if the$/;"	v
scattering_calculation	backup/transport_140314.h	/^int scattering_calculation;     \/* 0: corteo database, 1: MAGIC  *\/$/;"	v
simulation_type	backup/transport_140314.h	/^int simulation_type;  \/* How to do the simulation.$/;"	v
single_ion_sputter_yields	backup/transport_140314.h	/^int single_ion_sputter_yields;  \/* if 1, iradina will store sputter yields for single ions$/;"	v
sputter_yield_histogram	backup/transport_140314.h	/^int *sputter_yield_histogram;   \/* array that stores single ion sputter yield histogram *\/$/;"	v
status_update_interval	backup/transport_140314.h	/^int    status_update_interval;  \/* After so many ions, the status is written to the status file$/;"	v
storage_interval	backup/transport_140314.h	/^int    storage_interval;        \/* dump the target arrays into the files every such number of ions *\/$/;"	v
store_energy_deposit	backup/transport_140314.h	/^int store_energy_deposit;  \/* if 1, array with deposited energy are created and stored;$/;"	v
store_exiting_limit	backup/transport_140314.h	/^int store_exiting_limit;     \/* maximum number of exiting recoils to be stored *\/$/;"	v
store_exiting_recoils	backup/transport_140314.h	/^int store_exiting_recoils;   \/* 1 if all exiting recoils should be stored *\/$/;"	v
store_ion_paths	backup/transport_140314.h	/^int store_ion_paths;  \/* 1 if the exact paths should be stored (interesting for debugging stuff *\/$/;"	v
store_path_limit	backup/transport_140314.h	/^int store_path_limit;        \/* only for so many ions, the exact paths and recoil cascades are stored *\/$/;"	v
store_recoil_cascades	backup/transport_140314.h	/^int store_recoil_cascades;  \/* 1 if the exact recoils cascades should be stored$/;"	v
store_transmitted_ions	backup/transport_140314.h	/^int store_transmitted_ions;  \/* 1 if true *\/$/;"	v
straggling_model	backup/transport_140314.h	/^int straggling_model;       \/* how to calc straggling *\/$/;"	v
transmission_pointer	backup/transport_140314.h	/^int transmission_pointer;    \/* point to next free index in array *\/$/;"	v
transmit_list	backup/transport_140314.h	/^struct transmitted_ion *transmit_list;  \/* list of transmitted ions *\/$/;"	v	typeref:struct:transmitted_ion
transmitted_ion	backup/transport_140314.h	/^struct transmitted_ion       \/* describes an ion that has been transmitted (left the target) *\/$/;"	s
transport_type	backup/transport_140314.h	/^int transport_type;             \/* 0: accurate, 1: Fast (like corteo) *\/$/;"	v
vx	backup/transport_140314.h	/^    float vx;                \/* exit velocity unit vector *\/$/;"	m	struct:transmitted_ion
vy	backup/transport_140314.h	/^    float vy;$/;"	m	struct:transmitted_ion
vz	backup/transport_140314.h	/^    float vz;$/;"	m	struct:transmitted_ion
x	backup/transport_140314.h	/^    float x;                 \/* exit position x *\/$/;"	m	struct:transmitted_ion
y	backup/transport_140314.h	/^    float y;                 \/* y *\/$/;"	m	struct:transmitted_ion
z	backup/transport_140314.h	/^    float z;                 \/* z *\/$/;"	m	struct:transmitted_ion
calc_surface_normal	backup/transport_140415.c	/^int calc_surface_normal (int old_cell, int new_cell, double *nx, double *ny, double *nz) {$/;"	f
check_and_correct_boundary	backup/transport_140415.c	/^int check_and_correct_boundary (float *dim, float target_size, float *target_size_max, int boundary) {$/;"	f
coll_c	backup/transport_140415.c	/^int coll_c;             \/* collide *\/$/;"	v
collision	backup/transport_140415.c	/^int collision (int proj_Z, float proj_M, int is_ion, float *energy, double target_x,$/;"	f
def_ion_enetry_pos	backup/transport_140415.c	/^void def_ion_enetry_pos (double *x, double *y, double *z) {$/;"	f
disp_c	backup/transport_140415.c	/^int disp_c;             \/* dispalcement *\/$/;"	v
electronic_stopping	backup/transport_140415.c	/^float electronic_stopping (int ionZ, float ionM, float ionE, int material) {$/;"	f
electronic_straggling	backup/transport_140415.c	/^float electronic_straggling (int ionZ, float ionM, float ionE, int material) {$/;"	f
escape_solid_c	backup/transport_140415.c	/^int escape_solid_c;     \/* *\/$/;"	v
int_c	backup/transport_140415.c	/^int int_c;              \/* interstitial *\/$/;"	v
ion_c	backup/transport_140415.c	/^int ion_c;              \/* ion *\/$/;"	v
irradiate_target	backup/transport_140415.c	/^int irradiate_target (void) {$/;"	f
leaving_ions_c	backup/transport_140415.c	/^int leaving_ions_c;     \/* *\/$/;"	v
leaving_recoils_c	backup/transport_140415.c	/^int leaving_recoils_c;  \/* *\/$/;"	v
miss_c	backup/transport_140415.c	/^int miss_c;             \/* missed collision *\/$/;"	v
projectile_transport	backup/transport_140415.c	/^int projectile_transport (int proj_Z, float proj_M, double proj_E, double proj_x,$/;"	f
refract_projectile2	backup/transport_140415.c	/^int refract_projectile2 (double *vx, double *vy, double *vz, double nx, double ny,$/;"	f
repl_c	backup/transport_140415.c	/^int repl_c;             \/* replacement *\/$/;"	v
rotate	backup/transport_140415.c	/^void rotate (double *l, double *m, double *n, unsigned int *azim_angle,$/;"	f
single_ion_sputter_counter	backup/transport_140415.c	/^int single_ion_sputter_counter;$/;"	v
sputter_c	backup/transport_140415.c	/^int sputter_c;          \/* sputtering *\/$/;"	v
update_xyz	backup/transport_140415.c	/^void update_xyz (double *x, double *y, double *z, double vx, double vy, double vz, double s) {$/;"	f
vac_c	backup/transport_140415.c	/^int vac_c;              \/* vacancy *\/$/;"	v
MAX_SPUTTERED	backup/transport_140415.h	129;"	d
TRANSPORT_H	backup/transport_140415.h	13;"	d
beam_spread	backup/transport_140415.h	/^float beam_spread;           \/* in nm, only relevant for option 3 *\/$/;"	v
chu_values	backup/transport_140415.h	/^float chu_values[98][4];    \/* Values to calculate straggling according to Chu's model;$/;"	v
detailed_sputtering	backup/transport_140415.h	/^int detailed_sputtering;  \/* Needs to be set to 1, if you want to get better results regarding$/;"	v
display_interval	backup/transport_140415.h	/^int    display_interval;        \/* display status every so many ions *\/$/;"	v
energy	backup/transport_140415.h	/^    float  energy;            \/* exit energy *\/$/;"	m	struct:transmitted_ion
enter_x	backup/transport_140415.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_y	backup/transport_140415.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_z	backup/transport_140415.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
flight_length_const	backup/transport_140415.h	/^float flight_length_const;  \/* If constant flight length is selected, then this is it (in nm). *\/$/;"	v
flight_length_type	backup/transport_140415.h	/^int flight_length_type;    \/* Flight lengths between collisions can be selected by three$/;"	v
ion_M	backup/transport_140415.h	/^float ion_M;                  \/* mass of the ion *\/$/;"	v
ion_Z	backup/transport_140415.h	/^int   ion_Z;                  \/* proton number *\/$/;"	v
ion_distribution	backup/transport_140415.h	/^int   ion_distribution;      \/* 0 for random ion entry positions,$/;"	v
ion_initial_energy	backup/transport_140415.h	/^float ion_initial_energy;     \/* impinging energy *\/$/;"	v
ion_paths_fp	backup/transport_140415.h	/^FILE *ion_paths_fp;         \/* the file with the ion paths will be open all the time if the paths$/;"	v
ion_vx	backup/transport_140415.h	/^float ion_vx;                \/* vector of ion velocity, normalized to 1 *\/$/;"	v
ion_vy	backup/transport_140415.h	/^float ion_vy;                \/* Note, that the ion is NOT described by its actual velocity vector, *\/$/;"	v
ion_vz	backup/transport_140415.h	/^float ion_vz;                \/* but by the flying direction vector of length 1 and its energy. *\/$/;"	v
leaving_ions	backup/transport_140415.h	/^int leaving_ions[8];        \/* number of ions, leaving target in each direction\/quadrants, ygli *\/$/;"	v
max_annular_coll_volumes	backup/transport_140415.h	/^int max_annular_coll_volumes;  \/* According to W.Eckstein "Computer Simulation if Ion-Solid$/;"	v
max_no_ions	backup/transport_140415.h	/^int   max_no_ions;            \/* maximum number of ions *\/$/;"	v
min_energy	backup/transport_140415.h	/^float min_energy;            \/* minimum energy below which all projectiles are stopped *\/$/;"	v
override_energy	backup/transport_140415.h	/^float  override_energy;         \/* for command-line argument override of ion energy *\/$/;"	v
override_max_ions	backup/transport_140415.h	/^int    override_max_ions;       \/* for command-line argument override of maximum number of ions *\/$/;"	v
recoil_cascades_fp	backup/transport_140415.h	/^FILE *recoil_cascades_fp;   \/* the file with the recoil cascades will be open all the time if the$/;"	v
scattering_calculation	backup/transport_140415.h	/^int scattering_calculation;     \/* 0: corteo database, 1: MAGIC  *\/$/;"	v
simulation_type	backup/transport_140415.h	/^int simulation_type;  \/* How to do the simulation.$/;"	v
single_ion_sputter_yields	backup/transport_140415.h	/^int single_ion_sputter_yields;  \/* if 1, iradina will store sputter yields for single ions$/;"	v
sputter_yield_histogram	backup/transport_140415.h	/^int *sputter_yield_histogram;   \/* array that stores single ion sputter yield histogram *\/$/;"	v
status_update_interval	backup/transport_140415.h	/^int    status_update_interval;  \/* After so many ions, the status is written to the status file$/;"	v
storage_interval	backup/transport_140415.h	/^int    storage_interval;        \/* dump the target arrays into the files every such number of ions *\/$/;"	v
store_energy_deposit	backup/transport_140415.h	/^int store_energy_deposit;  \/* if 1, array with deposited energy are created and stored;$/;"	v
store_exiting_limit	backup/transport_140415.h	/^int store_exiting_limit;     \/* maximum number of exiting recoils to be stored *\/$/;"	v
store_exiting_recoils	backup/transport_140415.h	/^int store_exiting_recoils;   \/* 1 if all exiting recoils should be stored *\/$/;"	v
store_ion_paths	backup/transport_140415.h	/^int store_ion_paths;  \/* 1 if the exact paths should be stored (interesting for debugging stuff *\/$/;"	v
store_path_limit	backup/transport_140415.h	/^int store_path_limit;        \/* only for so many ions, the exact paths and recoil cascades are stored *\/$/;"	v
store_recoil_cascades	backup/transport_140415.h	/^int store_recoil_cascades;  \/* 1 if the exact recoils cascades should be stored$/;"	v
store_transmitted_ions	backup/transport_140415.h	/^int store_transmitted_ions;  \/* 1 if true *\/$/;"	v
straggling_model	backup/transport_140415.h	/^int straggling_model;       \/* how to calc straggling *\/$/;"	v
transmission_pointer	backup/transport_140415.h	/^int transmission_pointer;    \/* point to next free index in array *\/$/;"	v
transmit_list	backup/transport_140415.h	/^struct transmitted_ion *transmit_list;  \/* list of transmitted ions *\/$/;"	v	typeref:struct:transmitted_ion
transmitted_ion	backup/transport_140415.h	/^struct transmitted_ion       \/* describes an ion that has been transmitted (left the target) *\/$/;"	s
transport_type	backup/transport_140415.h	/^int transport_type;             \/* 0: accurate, 1: Fast (like corteo) *\/$/;"	v
vx	backup/transport_140415.h	/^    double vx;                \/* exit velocity unit vector *\/$/;"	m	struct:transmitted_ion
vy	backup/transport_140415.h	/^    double vy;$/;"	m	struct:transmitted_ion
vz	backup/transport_140415.h	/^    double vz;$/;"	m	struct:transmitted_ion
x	backup/transport_140415.h	/^    double x;                 \/* exit position x *\/$/;"	m	struct:transmitted_ion
y	backup/transport_140415.h	/^    double y;                 \/* y *\/$/;"	m	struct:transmitted_ion
z	backup/transport_140415.h	/^    double z;                 \/* z *\/$/;"	m	struct:transmitted_ion
coll_c	backup/transport_2_140429.c	/^int coll_c;             \/* collide *\/$/;"	v
collision	backup/transport_2_140429.c	/^int collision (int projZ, float projM, int is_ion, float *energy, double target_x,$/;"	f
def_ion_enetry_pos	backup/transport_2_140429.c	/^void def_ion_enetry_pos (double *x, double *y, double *z) {$/;"	f
disp_c	backup/transport_2_140429.c	/^int disp_c;             \/* dispalcement *\/$/;"	v
electronic_stopping	backup/transport_2_140429.c	/^float electronic_stopping (int ionZ, float ionM, float ionE, int material) {$/;"	f
electronic_straggling	backup/transport_2_140429.c	/^float electronic_straggling (int ionZ, float ionM, float ionE, int material) {$/;"	f
escape_solid_c	backup/transport_2_140429.c	/^int escape_solid_c;     \/* *\/$/;"	v
int_c	backup/transport_2_140429.c	/^int int_c;              \/* interstitial *\/$/;"	v
ion_c	backup/transport_2_140429.c	/^int ion_c;              \/* ion *\/$/;"	v
irradiate_target	backup/transport_2_140429.c	/^int irradiate_target (void) {$/;"	f
leaving_ions_c	backup/transport_2_140429.c	/^int leaving_ions_c;     \/* *\/$/;"	v
leaving_recoils_c	backup/transport_2_140429.c	/^int leaving_recoils_c;  \/* *\/$/;"	v
miss_c	backup/transport_2_140429.c	/^int miss_c;             \/* missed collision *\/$/;"	v
projectile_transport	backup/transport_2_140429.c	/^int projectile_transport (int projZ, float projM, float projE, double proj_x,$/;"	f
refract_projectile2	backup/transport_2_140429.c	/^int refract_projectile2 (double *vx, double *vy, double *vz, double nx, double ny,$/;"	f
repl_c	backup/transport_2_140429.c	/^int repl_c;             \/* replacement *\/$/;"	v
rotate	backup/transport_2_140429.c	/^void rotate (double *l, double *m, double *n, unsigned int *iazim_angle,$/;"	f
single_ion_sputter_counter	backup/transport_2_140429.c	/^int single_ion_sputter_counter;$/;"	v
sputter_c	backup/transport_2_140429.c	/^int sputter_c;          \/* sputtering *\/$/;"	v
update_xyz	backup/transport_2_140429.c	/^void update_xyz (double *x, double *y, double *z, double vx, double vy, double vz, double s) {$/;"	f
vac_c	backup/transport_2_140429.c	/^int vac_c;              \/* vacancy *\/$/;"	v
check_target_type_bulk	bulk.c	/^int check_target_type_bulk (double z, double vz, double flight_length) {$/;"	f
dist_to_surf	bulk.c	/^double dist_to_surf (double z, double z0, double vz) {$/;"	f
freepath_bulk	bulk.c	/^void freepath_bulk (int projZ, int projM, float *energy, double z, double vz,$/;"	f
read_bulk_shape	bulk.c	/^int read_bulk_shape (char *file_name) {$/;"	f
BULK_H	bulk.h	13;"	d
material_of_layer	bulk.h	/^int material_of_layer[21];$/;"	v
max_no_layers	bulk.h	/^int max_no_layers;$/;"	v
sect	bulk.h	/^float sect[21], sect0;$/;"	v
sect0	bulk.h	/^float sect[21], sect0;$/;"	v
shape_file	bulk.h	/^FILE* shape_file;    \/* csg shape parameters input file *\/$/;"	v
thick_of_layer	bulk.h	/^double thick_of_layer[21];$/;"	v
atomic_mass	const.c	/^float atomic_mass[] = { 92,$/;"	v
atomic_names	const.c	/^char atomic_names[][3] = { "XX",$/;"	v
most_abundant_isotope	const.c	/^float most_abundant_isotope[] = { 92,$/;"	v
CONST_H	const.h	15;"	d
D_TO_R	const.h	20;"	d
E2	const.h	23;"	d
NUMBERELEMENTS	const.h	25;"	d
PI	const.h	18;"	d
R_TO_D	const.h	19;"	d
SCREENCONST	const.h	22;"	d
atomic_mass	const.h	/^float atomic_mass[NUMBERELEMENTS];  \/* no use *\/$/;"	v
atomic_names	const.h	/^char  atomic_names[NUMBERELEMENTS][3];$/;"	v
most_abundant_isotope	const.h	/^float most_abundant_isotope[NUMBERELEMENTS];$/;"	v
change_axis	csg.c	/^void change_axis (int seq) {$/;"	f
check_target_type_csg	csg.c	/^int check_target_type_csg (double flight_length) {$/;"	f
column_intersect	csg.c	/^int column_intersect (int seq, double TT[]) {$/;"	f
cuboid_intersect	csg.c	/^int cuboid_intersect (int seq, double TT[]) {$/;"	f
ellipsoid_intersect	csg.c	/^int ellipsoid_intersect (int seq, double TT[]) {$/;"	f
freepath_csg	csg.c	/^void freepath_csg (int projZ, int projM, float *energy, double flight_length, double *step,$/;"	f
hyperboloid_intersect	csg.c	/^int hyperboloid_intersect (int seq, double TT[]) {$/;"	f
interface_path	csg.c	/^void interface_path (int s_count, double sect[][3], double *s, int projZ,$/;"	f
paraboloid_intersect	csg.c	/^int paraboloid_intersect (int seq, double TT[]) {$/;"	f
plane2_intersect	csg.c	/^int plane2_intersect (double N[], double LVO, double D[], double T2[]) {$/;"	f
polygon_intersect	csg.c	/^int polygon_intersect (double PTmp[][3], int Cnt, double P0[]) {$/;"	f
polyhedron_intersect	csg.c	/^int polyhedron_intersect (int seq, double TT[]) {$/;"	f
read_csg_shape	csg.c	/^int read_csg_shape (char *file_name) {$/;"	f
read_rotation	csg.c	/^int read_rotation (int i, double *ax, double *ay, double *az) {$/;"	f
read_scaling	csg.c	/^int read_scaling (int i) {$/;"	f
read_shearing	csg.c	/^int read_shearing (int i) {$/;"	f
read_translation	csg.c	/^int read_translation (int i) {$/;"	f
sect_sort	csg.c	/^void sect_sort (int *n, double sect[]) {$/;"	f
sphere_intersect	csg.c	/^int sphere_intersect (int seq, double TT[]) {$/;"	f
taper_intersect	csg.c	/^int taper_intersect (int seq, double TT[]) {$/;"	f
tetrahedron_intersect	csg.c	/^int tetrahedron_intersect (int seq, double TT[]) {$/;"	f
trans_TT	csg.c	/^void trans_TT (int seq, double TT[]) {$/;"	f
triangle_intersect_csg	csg.c	/^int triangle_intersect_csg (double P[][3], double *temp, int *flag) {$/;"	f
write_rotation	csg.c	/^int write_rotation (int i, double ax, double ay, double az) {$/;"	f
write_shear_scale	csg.c	/^int write_shear_scale (int i) {$/;"	f
write_translation	csg.c	/^int write_translation (int i) {$/;"	f
CSG_H	csg.h	15;"	d
LO	csg.h	/^double LV[3], LO[3];$/;"	v
LO1	csg.h	/^double LV1[3], LO1[3];$/;"	v
LV	csg.h	/^double LV[3], LO[3];$/;"	v
LV1	csg.h	/^double LV1[3], LO1[3];$/;"	v
R_shearing	csg.h	/^double R_shearing[20][3][3];$/;"	v
Ro	csg.h	/^int Ro[20];$/;"	v
SH_AA	csg.h	/^double SH_AA[20];$/;"	v
Sc	csg.h	/^int Sc[20];$/;"	v
Sh	csg.h	/^int Sh[20];$/;"	v
Tr	csg.h	/^int Tr[20];$/;"	v
abc2	csg.h	/^double abc2[20][3];$/;"	v
column_R2	csg.h	/^double column_R2[20];$/;"	v
column_height	csg.h	/^double column_height[20];$/;"	v
dc	csg.h	/^double dc[20][3][2];$/;"	v
hyperboloid_AA	csg.h	/^double hyperboloid_AA[20];$/;"	v
hyperboloid_BB	csg.h	/^double hyperboloid_BB[20];$/;"	v
hyperboloid_RR	csg.h	/^double hyperboloid_RR[20];$/;"	v
hyperboloid_distance	csg.h	/^double hyperboloid_distance[20];$/;"	v
hyperboloid_height	csg.h	/^double hyperboloid_height[20];$/;"	v
hyperboloid_radius	csg.h	/^double hyperboloid_radius[20];$/;"	v
is_full	csg.h	/^int is_full[20];     \/* materials in shape elements *\/$/;"	v
my_shape	csg.h	/^int my_shape[20];    \/* indexes of shape elements *\/$/;"	v
orientation	csg.h	/^double orientation[20][3][3];$/;"	v
paraboloid_RR	csg.h	/^double paraboloid_RR[20];$/;"	v
paraboloid_RRH	csg.h	/^double paraboloid_RRH[20];$/;"	v
paraboloid_height	csg.h	/^double paraboloid_height[20];$/;"	v
paraboloid_radius	csg.h	/^double paraboloid_radius[20];$/;"	v
point	csg.h	/^double point[20][4][3];$/;"	v
polygon_Cnt	csg.h	/^int polygon_Cnt[20];$/;"	v
polygon_vertex	csg.h	/^double polygon_vertex[20][20][20][3];$/;"	v
rxyz	csg.h	/^double rxyz[20][3][3];$/;"	v
s_count	csg.h	/^int s_count;         \/* number of shape elements *\/$/;"	v
scaling	csg.h	/^double scaling[20][3];$/;"	v
shearing	csg.h	/^double shearing[20][3][3];$/;"	v
shift	csg.h	/^double shift[20][3];$/;"	v
sphere_C	csg.h	/^double sphere_C[20][3];$/;"	v
sphere_R2	csg.h	/^double sphere_R2[20];$/;"	v
taper_TgT2	csg.h	/^double taper_TgT2[20];$/;"	v
taper_height	csg.h	/^double taper_height[20];$/;"	v
vertex_Cnt	csg.h	/^int vertex_Cnt[20][20];$/;"	v
check_material_type	fetm.c	/^void check_material_type (int *in_or_not, double x, double y, double z, int projZ,$/;"	f
check_surf_bind	fetm.c	/^float check_surf_bind (int current_material_index, int projZ) {$/;"	f
check_target_type_fetm	fetm.c	/^int check_target_type_fetm (double x, double y, double z, double vx, double vy, double vz,$/;"	f
freepath_fetm	fetm.c	/^void freepath_fetm (double *x, double *y, double *z, double *vx, double *vy, double *vz,$/;"	f
juintersect	fetm.c	/^int juintersect (double *x, double *y, double *z, double vx, double vy, double vz) {$/;"	f
make_line	fetm.c	/^void make_line (double x, double y, double z, double vx,$/;"	f
read_fetm_shape	fetm.c	/^int read_fetm_shape (char *file_name) {$/;"	f
refraction	fetm.c	/^void refraction (double NT[], double *vx, double *vy, double *vz, int *S_flag,$/;"	f
transmission	fetm.c	/^void transmission (double uz, int idied, float energy, float U0) {$/;"	f
triangle_intersect_fetm	fetm.c	/^int triangle_intersect_fetm (double trix1, double triy1, double triz1, double trix2,$/;"	f
FETM_H	fetm.h	15;"	d
GBOX	fetm.h	/^    float GBOX[800][9];     \/* triangle vertex coordinates *\/$/;"	m	struct:GRIDBOX
GRB	fetm.h	/^struct GRIDBOX ***GRB;$/;"	v	typeref:struct:GRIDBOX
GRIDBOX	fetm.h	/^struct GRIDBOX  \/* geometry *\/$/;"	s
ax	fetm.h	/^double ax, ay, az;  \/*  *\/$/;"	v
ay	fetm.h	/^double ax, ay, az;  \/*  *\/$/;"	v
az	fetm.h	/^double ax, ay, az;  \/*  *\/$/;"	v
box_count_x	fetm.h	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_count_y	fetm.h	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_count_z	fetm.h	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_end_x0	fetm.h	/^float box_end_x0, box_end_y0, box_end_z0;$/;"	v
box_end_y0	fetm.h	/^float box_end_x0, box_end_y0, box_end_z0;$/;"	v
box_end_z0	fetm.h	/^float box_end_x0, box_end_y0, box_end_z0;$/;"	v
box_length_x	fetm.h	/^float box_length_x, box_length_y, box_length_z;$/;"	v
box_length_y	fetm.h	/^float box_length_x, box_length_y, box_length_z;$/;"	v
box_length_z	fetm.h	/^float box_length_x, box_length_y, box_length_z;$/;"	v
box_size_x	fetm.h	/^double box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_size_y	fetm.h	/^double box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_size_z	fetm.h	/^double box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
di	fetm.h	/^int    di, dj, dk;  \/*  *\/$/;"	v
dj	fetm.h	/^int    di, dj, dk;  \/*  *\/$/;"	v
dk	fetm.h	/^int    di, dj, dk;  \/*  *\/$/;"	v
flag	fetm.h	/^    int   flag;             \/* used for triangulating *\/$/;"	m	struct:GRIDBOX
line_flag	fetm.h	/^int    line_flag;$/;"	v
mater_type	fetm.h	/^    int   mater_type[800];  \/* material type inside this triangle, 100 -> 800 *\/$/;"	m	struct:GRIDBOX
num_triangles	fetm.h	/^    int   num_triangles;    \/* number of triangles in this box *\/$/;"	m	struct:GRIDBOX
rx	fetm.h	/^double rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
ry	fetm.h	/^double rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
rz	fetm.h	/^double rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
z0_max	fetm.h	/^float z0_max;$/;"	v
check_split_input_file	fileio.c	/^int check_split_input_file (char *file_name) {$/;"	f
combine_files	fileio.c	/^int combine_files (int count, ...) {$/;"	f
display_a_file	fileio.c	/^int display_a_file (char *file_name) {$/;"	f
do_depth_dist_statistics	fileio.c	/^void do_depth_dist_statistics (void) {$/;"	f
open_file_continuous	fileio.c	/^FILE *open_file_continuous (char *base_name, char *extension) {$/;"	f
read_config_file_data	fileio.c	/^int read_config_file_data (char *par_name, char *par_value) {$/;"	f
read_config_file_data_block	fileio.c	/^int read_config_file_data_block (char *block_name) {$/;"	f
read_float_block	fileio.c	/^int read_float_block (char *file_name, int offset, int count, float *array) {$/;"	f
read_init_file	fileio.c	/^int read_init_file (int (*read_data_block) (char *block_name),$/;"	f
split_single_input_file	fileio.c	/^int split_single_input_file (char *file_name) {$/;"	f
store_depth_dist_array	fileio.c	/^int store_depth_dist_array (char *file_name) {$/;"	f
store_results_cfg	fileio.c	/^int store_results_cfg (char *base_name) {$/;"	f
store_results_iradina	fileio.c	/^int store_results_iradina (char *base_name) {$/;"	f
store_transmission_array	fileio.c	/^int store_transmission_array (char *file_name, struct transmitted_ion *trans_array,$/;"	f
sum_up_material_arrays	fileio.c	/^void sum_up_material_arrays (void) {$/;"	f
write_double_array_to_cfg_file	fileio.c	/^int write_double_array_to_cfg_file (char *file_name, double *source_array1,$/;"	f
write_double_array_to_file	fileio.c	/^int write_double_array_to_file (char *file_name, double *source_array, int count, int file_type) {$/;"	f
write_int_array_to_cfg_file	fileio.c	/^int write_int_array_to_cfg_file (char *file_name, int mat_i, int *source_array_total,$/;"	f
write_int_array_to_file	fileio.c	/^int write_int_array_to_file (char *file_name, int *source_array, int count, int file_type) {$/;"	f
write_string_to_file	fileio.c	/^int write_string_to_file (char *file_name, char *str) {$/;"	f
FILEIO_H	fileio.h	16;"	d
single_input_file	fileio.h	/^int single_input_file;  \/* if 0, then multiple files (normal).$/;"	v
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
D_index	index.c	/^unsigned long D_index (float D_val) {$/;"	f
D_val	index.c	/^float D_val (unsigned long index) {$/;"	f
E_index	index.c	/^unsigned long E_index (float E_val) {$/;"	f
E_val	index.c	/^float E_val (unsigned long index) {$/;"	f
S_index	index.c	/^unsigned long S_index (float S_val) {$/;"	f
S_val	index.c	/^float S_val (unsigned long index) {$/;"	f
BIASD	index.h	42;"	d
BIASD	index.h	61;"	d
BIASE	index.h	30;"	d
BIASE	index.h	49;"	d
BIASS	index.h	36;"	d
BIASS	index.h	55;"	d
DIMD	index.h	41;"	d
DIMD	index.h	60;"	d
DIME	index.h	29;"	d
DIME	index.h	48;"	d
DIMS	index.h	35;"	d
DIMS	index.h	54;"	d
D_max_err	index.h	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
D_min_err	index.h	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
E_max_err	index.h	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
E_min_err	index.h	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
INDEX_BOUND_CHECKING	index.h	19;"	d
INDEX_H	index.h	16;"	d
MAXD	index.h	40;"	d
MAXD	index.h	59;"	d
MAXE	index.h	28;"	d
MAXE	index.h	47;"	d
MAXS	index.h	34;"	d
MAXS	index.h	53;"	d
MIND	index.h	39;"	d
MIND	index.h	58;"	d
MINE	index.h	27;"	d
MINE	index.h	46;"	d
MINS	index.h	33;"	d
MINS	index.h	52;"	d
SHIFTD	index.h	43;"	d
SHIFTD	index.h	62;"	d
SHIFTE	index.h	31;"	d
SHIFTE	index.h	50;"	d
SHIFTS	index.h	37;"	d
SHIFTS	index.h	56;"	d
S_max_err	index.h	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
S_min_err	index.h	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
fill_fast_sqrt_table	init.c	/^void fill_fast_sqrt_table (void) {$/;"	f
init_configuration	init.c	/^int init_configuration (char *ConfigFileName) {$/;"	f
load_Chu_straggling_values	init.c	/^int load_Chu_straggling_values () {$/;"	f
load_inverse_Erf	init.c	/^int load_inverse_Erf () {$/;"	f
screening_type	init.c	18;"	d	file:
MAXERFLIST	init.h	45;"	d
azim_angle	init.h	/^unsigned int azim_angle;        \/* points to next azimutal angle to choose *\/$/;"	v
erf_list_pointer	init.h	/^unsigned int erf_list_pointer;  \/* points to next erf element to use *\/$/;"	v
init_H	init.h	15;"	d
inv_sqrt_table	init.h	/^float inv_sqrt_table[1<<16];$/;"	v
inv_sqrt_table_exp	init.h	/^float inv_sqrt_table_exp[256];$/;"	v
inverse_erf_list	init.h	/^float inverse_erf_list[MAXERFLIST];  \/* list of evenly distributed but randomly ordered$/;"	v
ran_list	init.h	/^unsigned int ran_list;          \/* points to next entry in the random list *\/$/;"	v
ran_log_list	init.h	/^unsigned int ran_log_list;      \/* points to next entry in the random sqrt logarithmic list *\/$/;"	v
sqrt_table	init.h	/^float sqrt_table[1<<16];$/;"	v
sqrt_table_exp	init.h	/^float sqrt_table_exp[256];$/;"	v
display_startup_message	iran3d.c	/^int display_startup_message () {$/;"	f
main	iran3d.c	/^int main (int argc, char *argv[]) {$/;"	f
ConfigFileName	iran3d.h	/^char *ConfigFileName;          \/* name of the general input config file *\/$/;"	v
ConversionFileName	iran3d.h	/^char *ConversionFileName;      \/* name of the converted input file (when converting from$/;"	v
ElementsFileName	iran3d.h	/^char *ElementsFileName;        \/* name of the file that defines the elements in the target$/;"	v
IRAN3D_H	iran3d.h	19;"	d
MAX_FILENAME_LENGTH	iran3d.h	69;"	d
MaterialsFileName	iran3d.h	/^char *MaterialsFileName;       \/* name of the file that defines the materials in the target *\/$/;"	v
OutputFileBaseName	iran3d.h	/^char *OutputFileBaseName;      \/* all outputfiles begin with this name, so that's put them in a$/;"	v
PROJ_HANGUP_SAFETY	iran3d.h	59;"	d
RELEASESTRING	iran3d.h	66;"	d
RENORM_VELOCITIES	iran3d.h	55;"	d
SAFE_ROTATION	iran3d.h	50;"	d
SAFE_SQR_ROTATION	iran3d.h	51;"	d
SUBSUBVERSION	iran3d.h	65;"	d
SUBVERSION	iran3d.h	64;"	d
TargetDensityMultFileName	iran3d.h	/^char *TargetDensityMultFileName;  \/* *\/$/;"	v
TargetStructureFileName	iran3d.h	/^char *TargetStructureFileName; \/* filename of the file that define the structure of the target *\/$/;"	v
VERSION	iran3d.h	63;"	d
VERSIONCOMMENT	iran3d.h	67;"	d
VERSIONDATE	iran3d.h	62;"	d
create_status_file	iran3d.h	/^int    create_status_file;     \/* if this is 1, then iran3d output its status regularly to$/;"	v
do_not_store_damage	iran3d.h	/^int   do_not_store_damage;     \/* if 1, then far fewer data are stored to disc... saves memory *\/$/;"	v
mem_usage	iran3d.h	/^unsigned long int mem_usage;   \/* if mem_usage active, then sum it up here (in bytes) *\/$/;"	v
mem_usage_details	iran3d.h	/^int mem_usage_details;         \/* if 1, print more details for memory usage *\/$/;"	v
mem_usage_only	iran3d.h	/^int mem_usage_only;            \/* if 1, then do not simulate anything, just estimate memory usage *\/$/;"	v
normalize_output	iran3d.h	/^int normalize_output;          \/* if 1, the output of the program will be normalized to$/;"	v
output_format	iran3d.h	/^int output_format;             \/* if 1, iradiana output format; if 2, cfg output_format *\/$/;"	v
print_level	iran3d.h	/^int print_level;               \/* determines how much stuff is printed to the console$/;"	v
start_id_string	iran3d.h	/^char *start_id_string;         \/* string that helps other programs to identify iran3d output *\/$/;"	v
unit_conversion_factor	iran3d.h	/^double unit_conversion_factor; \/* This converts output to unit of (1\/cm^3)per(1\/cm^2) *\/$/;"	v
wait_before_end	iran3d.h	/^int wait_before_end;           \/* if 1, the program only quits after pressing return key *\/$/;"	v
BIASD	iran3d_all.c	4935;"	d	file:
BIASD	iran3d_all.c	4954;"	d	file:
BIASE	iran3d_all.c	4923;"	d	file:
BIASE	iran3d_all.c	4942;"	d	file:
BIASS	iran3d_all.c	4929;"	d	file:
BIASS	iran3d_all.c	4948;"	d	file:
CONST_H	iran3d_all.c	487;"	d	file:
CSG_H	iran3d_all.c	6970;"	d	file:
ConfigFileName	iran3d_all.c	/^char *ConfigFileName;          \/* name of the general input config file *\/$/;"	v
ConversionFileName	iran3d_all.c	/^char *ConversionFileName;      \/* name of the converted input file (when converting from$/;"	v
DIMD	iran3d_all.c	4934;"	d	file:
DIMD	iran3d_all.c	4953;"	d	file:
DIME	iran3d_all.c	4922;"	d	file:
DIME	iran3d_all.c	4941;"	d	file:
DIMS	iran3d_all.c	4928;"	d	file:
DIMS	iran3d_all.c	4947;"	d	file:
D_TO_R	iran3d_all.c	492;"	d	file:
D_index	iran3d_all.c	/^unsigned long D_index (float D_val) {$/;"	f
D_max_err	iran3d_all.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
D_min_err	iran3d_all.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
D_val	iran3d_all.c	/^float D_val (unsigned long index) {$/;"	f
E2	iran3d_all.c	495;"	d	file:
E_index	iran3d_all.c	/^unsigned long E_index (float E_val) {$/;"	f
E_max_err	iran3d_all.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
E_min_err	iran3d_all.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
E_val	iran3d_all.c	/^float E_val (unsigned long index) {$/;"	f
ElementsFileName	iran3d_all.c	/^char *ElementsFileName;        \/* name of the file that defines the elements in the target$/;"	v
FETM_H	iran3d_all.c	8950;"	d	file:
FILEIO_H	iran3d_all.c	5200;"	d	file:
GBOX	iran3d_all.c	/^    float GBOX[800][9];     \/* triangle vertex coordinates *\/$/;"	m	struct:GRIDBOX	file:
GRB	iran3d_all.c	/^struct GRIDBOX ***GRB;$/;"	v	typeref:struct:GRIDBOX
GRIDBOX	iran3d_all.c	/^struct GRIDBOX  \/* geometry *\/$/;"	s	file:
H	iran3d_all.c	/^double H (double u, double x0, double epsilon, double s) {$/;"	f
HEADERSIZE	iran3d_all.c	4399;"	d	file:
INDEX_BOUND_CHECKING	iran3d_all.c	4912;"	d	file:
INDEX_H	iran3d_all.c	4909;"	d	file:
IRAN3D_H	iran3d_all.c	19;"	d	file:
LO	iran3d_all.c	/^double LV[3], LO[3];$/;"	v
LO1	iran3d_all.c	/^double LV1[3], LO1[3];$/;"	v
LV	iran3d_all.c	/^double LV[3], LO[3];$/;"	v
LV1	iran3d_all.c	/^double LV1[3], LO1[3];$/;"	v
MATERIAL_H	iran3d_all.c	1082;"	d	file:
MATRIX_H	iran3d_all.c	4303;"	d	file:
MAX	iran3d_all.c	11507;"	d	file:
MAXAZILIST	iran3d_all.c	12272;"	d	file:
MAXD	iran3d_all.c	4933;"	d	file:
MAXD	iran3d_all.c	4952;"	d	file:
MAXE	iran3d_all.c	4921;"	d	file:
MAXE	iran3d_all.c	4940;"	d	file:
MAXERFLIST	iran3d_all.c	631;"	d	file:
MAXLOGLIST	iran3d_all.c	12271;"	d	file:
MAXRANLIST	iran3d_all.c	12273;"	d	file:
MAXS	iran3d_all.c	4927;"	d	file:
MAXS	iran3d_all.c	4946;"	d	file:
MAX_ELEMENT_NO	iran3d_all.c	1112;"	d	file:
MAX_ELEMENT_NO	iran3d_all.c	4328;"	d	file:
MAX_EL_PER_MAT	iran3d_all.c	1110;"	d	file:
MAX_FILENAME_LENGTH	iran3d_all.c	69;"	d	file:
MAX_NO_MATERIALS	iran3d_all.c	1111;"	d	file:
MAX_SPUTTERED	iran3d_all.c	3011;"	d	file:
MAX_STOPPING_ENTRIES	iran3d_all.c	2180;"	d	file:
MIND	iran3d_all.c	4932;"	d	file:
MIND	iran3d_all.c	4951;"	d	file:
MINE	iran3d_all.c	4920;"	d	file:
MINE	iran3d_all.c	4939;"	d	file:
MINS	iran3d_all.c	4926;"	d	file:
MINS	iran3d_all.c	4945;"	d	file:
MaterialsFileName	iran3d_all.c	/^char *MaterialsFileName;       \/* name of the file that defines the materials in the target *\/$/;"	v
NSUM	iran3d_all.c	4393;"	d	file:
NSUM2	iran3d_all.c	4394;"	d	file:
NUMBERELEMENTS	iran3d_all.c	497;"	d	file:
OutputFileBaseName	iran3d_all.c	/^char *OutputFileBaseName;      \/* all outputfiles begin with this name, so that's put them in a$/;"	v
PHI	iran3d_all.c	/^double (*PHI) (double x);$/;"	v
PI	iran3d_all.c	490;"	d	file:
PROJ_HANGUP_SAFETY	iran3d_all.c	59;"	d	file:
RANDOM_H	iran3d_all.c	12256;"	d	file:
RELEASESTRING	iran3d_all.c	66;"	d	file:
RENORM_VELOCITIES	iran3d_all.c	55;"	d	file:
R_TO_D	iran3d_all.c	491;"	d	file:
R_shearing	iran3d_all.c	/^double R_shearing[20][3][3];$/;"	v
Ro	iran3d_all.c	/^int Ro[20];$/;"	v
SAFE_ROTATION	iran3d_all.c	50;"	d	file:
SAFE_SQR_ROTATION	iran3d_all.c	51;"	d	file:
SCREENCONST	iran3d_all.c	494;"	d	file:
SHIFTD	iran3d_all.c	4936;"	d	file:
SHIFTD	iran3d_all.c	4955;"	d	file:
SHIFTE	iran3d_all.c	4924;"	d	file:
SHIFTE	iran3d_all.c	4943;"	d	file:
SHIFTS	iran3d_all.c	4930;"	d	file:
SHIFTS	iran3d_all.c	4949;"	d	file:
SH_AA	iran3d_all.c	/^double SH_AA[20];$/;"	v
SUBSUBVERSION	iran3d_all.c	65;"	d	file:
SUBVERSION	iran3d_all.c	64;"	d	file:
S_index	iran3d_all.c	/^unsigned long S_index (float S_val) {$/;"	f
S_max_err	iran3d_all.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
S_min_err	iran3d_all.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
S_val	iran3d_all.c	/^float S_val (unsigned long index) {$/;"	f
Sc	iran3d_all.c	/^int Sc[20];$/;"	v
Sh	iran3d_all.c	/^int Sh[20];$/;"	v
TARGET_H	iran3d_all.c	2141;"	d	file:
THETAERR	iran3d_all.c	4396;"	d	file:
TRANSPORT_H	iran3d_all.c	2889;"	d	file:
TRIANGULATE_H	iran3d_all.c	10634;"	d	file:
TargetCompositionFileName	iran3d_all.c	/^char *TargetCompositionFileName;$/;"	v
TargetDensityMultFileName	iran3d_all.c	/^char *TargetDensityMultFileName;  \/* *\/$/;"	v
TargetStructureFileName	iran3d_all.c	/^char *TargetStructureFileName; \/* filename of the file that define the structure of the target *\/$/;"	v
Tr	iran3d_all.c	/^int Tr[20];$/;"	v
UTILS_H	iran3d_all.c	11480;"	d	file:
VERSION	iran3d_all.c	63;"	d	file:
VERSIONCOMMENT	iran3d_all.c	67;"	d	file:
VERSIONDATE	iran3d_all.c	62;"	d	file:
a2f	iran3d_all.c	/^float a2f (char *s) {$/;"	f
abc2	iran3d_all.c	/^double abc2[20][3];$/;"	v
add_int_array	iran3d_all.c	/^void add_int_array (int *dest, int *source, int count) {$/;"	f
atomic_distance	iran3d_all.c	/^    float atomic_distance;      \/* average inter-atomic distance [nm] *\/$/;"	m	struct:material	file:
atomic_mass	iran3d_all.c	/^float atomic_mass[NUMBERELEMENTS];  \/* no use *\/$/;"	v
atomic_mass	iran3d_all.c	/^float atomic_mass[] = { 92,$/;"	v
atomic_names	iran3d_all.c	/^char  atomic_names[NUMBERELEMENTS][3];$/;"	v
atomic_names	iran3d_all.c	/^char atomic_names[][3] = { "XX",$/;"	v
ax	iran3d_all.c	/^double ax, ay, az;  \/*  *\/$/;"	v
ay	iran3d_all.c	/^double ax, ay, az;  \/*  *\/$/;"	v
az	iran3d_all.c	/^double ax, ay, az;  \/*  *\/$/;"	v
azim_angle	iran3d_all.c	/^unsigned int azim_angle;        \/* points to next azimutal angle to choose *\/$/;"	v
beam_spread	iran3d_all.c	/^float beam_spread;           \/* in nm, only relevant for option 3 *\/$/;"	v
box_count_x	iran3d_all.c	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_count_y	iran3d_all.c	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_count_z	iran3d_all.c	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_end_x0	iran3d_all.c	/^float box_end_x0, box_end_y0, box_end_z0;$/;"	v
box_end_y0	iran3d_all.c	/^float box_end_x0, box_end_y0, box_end_z0;$/;"	v
box_end_z0	iran3d_all.c	/^float box_end_x0, box_end_y0, box_end_z0;$/;"	v
box_length_x	iran3d_all.c	/^float box_length_x, box_length_y, box_length_z;$/;"	v
box_length_y	iran3d_all.c	/^float box_length_x, box_length_y, box_length_z;$/;"	v
box_length_z	iran3d_all.c	/^float box_length_x, box_length_y, box_length_z;$/;"	v
box_size_x	iran3d_all.c	/^double box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_size_y	iran3d_all.c	/^double box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_size_z	iran3d_all.c	/^double box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_start_x0	iran3d_all.c	/^float box_start_x0;    \/* fetm box start point *\/$/;"	v
box_start_y0	iran3d_all.c	/^float box_start_y0;$/;"	v
box_start_z0	iran3d_all.c	/^float box_start_z0;$/;"	v
cal_direct	iran3d_all.c	/^void cal_direct (double xyz[], double *sin_theta, double *cos_theta,$/;"	f
cal_relative_target_atom_position	iran3d_all.c	/^void cal_relative_target_atom_position (double vx, double vy, double vz, double *px,$/;"	f
cal_theta	iran3d_all.c	/^double cal_theta (double epsilon, double s, unsigned int nsum) {$/;"	f
calc_matrix	iran3d_all.c	/^int calc_matrix (unsigned int screening_type, int show_progress, char *file_name) {$/;"	f
calculate_normalization_factor	iran3d_all.c	/^void calculate_normalization_factor (int num_of_ions) {$/;"	f
cell_count	iran3d_all.c	/^    int   cell_count;  \/* number of cells that consist of this material *\/$/;"	m	struct:material	file:
cell_count	iran3d_all.c	/^int cell_count;        \/* total number of cells *\/$/;"	v
cell_count_x	iran3d_all.c	/^int cell_count_x;      \/* number of cells in x-direction (>=1) *\/$/;"	v
cell_count_y	iran3d_all.c	/^int cell_count_y;      \/* number of cells in y-direction (>=1) *\/$/;"	v
cell_count_z	iran3d_all.c	/^int cell_count_z;      \/* number of cells in z-direction (>=1) *\/$/;"	v
cell_size_x	iran3d_all.c	/^float cell_size_x;     \/* size of cells in x-direction in nm *\/$/;"	v
cell_size_y	iran3d_all.c	/^float cell_size_y;     \/* size of cells in y-direction in nm *\/$/;"	v
cell_size_z	iran3d_all.c	/^float cell_size_z;     \/* size of cells in z-direction in nm *\/$/;"	v
cell_volume	iran3d_all.c	/^float cell_volume;     \/* product of the above three *\/$/;"	v
change_axis	iran3d_all.c	/^void change_axis (int seq) {$/;"	f
check_material_type	iran3d_all.c	/^void check_material_type (int *in_or_not, double x, double y, double z, int projZ,$/;"	f
check_split_input_file	iran3d_all.c	/^int check_split_input_file (char *file_name) {$/;"	f
check_surf_bind	iran3d_all.c	/^float check_surf_bind (int current_material_index, int projZ) {$/;"	f
check_target_type_csg	iran3d_all.c	/^int check_target_type_csg (double flight_length) {$/;"	f
check_target_type_fetm	iran3d_all.c	/^int check_target_type_fetm (double x, double y, double z, double vx, double vy, double vz,$/;"	f
chu_values	iran3d_all.c	/^float chu_values[98][4];    \/* Values to calculate straggling according to Chu's model;$/;"	v
coll_c	iran3d_all.c	/^int coll_c;             \/* collide *\/$/;"	v
collision	iran3d_all.c	/^int collision (int projZ, float projM, int is_ion, float *energy, double target_x,$/;"	f
column_R2	iran3d_all.c	/^double column_R2[20];$/;"	v
column_height	iran3d_all.c	/^double column_height[20];$/;"	v
column_intersect	iran3d_all.c	/^int column_intersect (int seq, double TT[]) {$/;"	f
combine_files	iran3d_all.c	/^int combine_files (int count, ...) {$/;"	f
compute_lists	iran3d_all.c	/^void compute_lists (void) {$/;"	f
conv_create_separate_elements	iran3d_all.c	/^int conv_create_separate_elements;$/;"	v
convert_material_to_element	iran3d_all.c	/^int convert_material_to_element (char *output_file) {$/;"	f
copy_double_array	iran3d_all.c	/^ double copy_double_array (double a[], double b[], int num_elements) {$/;"	f
copy_int_array	iran3d_all.c	/^ int copy_int_array (int a[], int b[], int num_elements) {$/;"	f
cos_azim_angle	iran3d_all.c	/^float cos_azim_angle[MAXAZILIST];$/;"	v
cos_scat	iran3d_all.c	/^    float *cos_scat;             \/* cosines of scattering angles, for each energy and p *\/$/;"	m	struct:scattering_matrix	file:
count_existing_elements	iran3d_all.c	/^int count_existing_elements (int *element_array) {$/;"	f
create_status_file	iran3d_all.c	/^int    create_status_file;     \/* if this is 1, then iran3d output its status regularly to$/;"	v
cross_product	iran3d_all.c	/^void cross_product (double a[], double b[], double c[]) {$/;"	f
cuboid_intersect	iran3d_all.c	/^int cuboid_intersect (int seq, double TT[]) {$/;"	f
d2f	iran3d_all.c	/^float d2f (double val) {$/;"	f
dc	iran3d_all.c	/^double dc[20][3][2];$/;"	v
def_ion_enetry_pos	iran3d_all.c	/^void def_ion_enetry_pos (double *x, double *y, double *z) {$/;"	f
density	iran3d_all.c	/^    float density;              \/* total atomic density in at\/cm^3 *\/$/;"	m	struct:material	file:
density_NM	iran3d_all.c	/^    float density_NM;           \/* total atomic density in at\/nm^3 *\/$/;"	m	struct:material	file:
detailed_sputtering	iran3d_all.c	/^int detailed_sputtering;  \/* Needs to be set to 1, if you want to get better results regarding$/;"	v
di	iran3d_all.c	/^int    di, dj, dk;  \/*  *\/$/;"	v
disp_c	iran3d_all.c	/^int disp_c;             \/* dispalcement *\/$/;"	v
display_a_file	iran3d_all.c	/^int display_a_file (char *file_name) {$/;"	f
display_interval	iran3d_all.c	/^int    display_interval;        \/* display status every so many ions *\/$/;"	v
display_startup_message	iran3d_all.c	/^int display_startup_message () {$/;"	f
dj	iran3d_all.c	/^int    di, dj, dk;  \/*  *\/$/;"	v
dk	iran3d_all.c	/^int    di, dj, dk;  \/*  *\/$/;"	v
do_depth_dist_statistics	iran3d_all.c	/^void do_depth_dist_statistics (void) {$/;"	f
do_not_store_damage	iran3d_all.c	/^int   do_not_store_damage;     \/* if 1, then far fewer data are stored to disc... saves memory *\/$/;"	v
dot_product	iran3d_all.c	/^double dot_product (double a[], double b[]) {$/;"	f
e_energy_loss	iran3d_all.c	/^void e_energy_loss (int projZ, int projM, float projE, int mater_type, double s,$/;"	f
element_count	iran3d_all.c	/^    int   element_count;  \/* number of different elements contained in this material *\/$/;"	m	struct:material	file:
elemental_leaving_recoils	iran3d_all.c	/^    struct transmitted_ion** elemental_leaving_recoils; \/* arrays storing recoils that are$/;"	m	struct:material	typeref:struct:material::transmitted_ion	file:
elements_M	iran3d_all.c	/^    float elements_M[MAX_EL_PER_MAT];     \/* list of the element masses in this materials *\/$/;"	m	struct:material	file:
elements_Z	iran3d_all.c	/^    int   elements_Z[MAX_EL_PER_MAT];     \/* list of the elements contained in this materials *\/$/;"	m	struct:material	file:
elements_conc	iran3d_all.c	/^    float elements_conc[MAX_EL_PER_MAT];  \/* relative concentration of the elements *\/$/;"	m	struct:material	file:
elements_disp_energy	iran3d_all.c	/^    float elements_disp_energy[MAX_EL_PER_MAT];  \/* displacement energy for each element in eV *\/$/;"	m	struct:material	file:
elements_latt_energy	iran3d_all.c	/^    float elements_latt_energy[MAX_EL_PER_MAT];  \/* lattice energy for each element in eV *\/$/;"	m	struct:material	file:
elements_surf_energy	iran3d_all.c	/^    float elements_surf_energy[MAX_EL_PER_MAT];  \/* surface binding energy for each element in eV *\/$/;"	m	struct:material	file:
ellipsoid_intersect	iran3d_all.c	/^int ellipsoid_intersect (int seq, double TT[]) {$/;"	f
energy	iran3d_all.c	/^    float  energy;            \/* exit energy *\/$/;"	m	struct:transmitted_ion	file:
enter_x	iran3d_all.c	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_y	iran3d_all.c	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_z	iran3d_all.c	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
erf_list_pointer	iran3d_all.c	/^unsigned int erf_list_pointer;  \/* points to next erf element to use *\/$/;"	v
escape_solid_c	iran3d_all.c	/^int escape_solid_c;     \/* *\/$/;"	v
existing_elements	iran3d_all.c	/^int existing_elements[MAX_ELEMENT_NO];  \/* This array holds a 1 for any element that might exist$/;"	v
fast_sqrt	iran3d_all.c	/^float fast_sqrt (float val) {$/;"	f
file_format	iran3d_all.c	/^int file_format;  \/* all list in Config.in *\/$/;"	v
fill_cos_sin_table	iran3d_all.c	/^void fill_cos_sin_table (float *cos_table, float *sin_table, float mr) {$/;"	f
fill_double_zero	iran3d_all.c	/^void fill_double_zero (double *array, int count) {$/;"	f
fill_fast_sqrt_table	iran3d_all.c	/^void fill_fast_sqrt_table (void) {$/;"	f
fill_int_zero	iran3d_all.c	/^void fill_int_zero (int *array, int count) {$/;"	f
find_x0	iran3d_all.c	/^double find_x0 (double epsilon, double s) {$/;"	f
finds	iran3d_all.c	/^double finds (double epsilon, double thetaCM) {$/;"	f
flag	iran3d_all.c	/^    int   flag;             \/* used for triangulating *\/$/;"	m	struct:GRIDBOX	file:
flight_length_const	iran3d_all.c	/^float flight_length_const;  \/* If constant flight length is selected, then this is it (in nm). *\/$/;"	v
flight_length_type	iran3d_all.c	/^int flight_length_type;    \/* Flight lengths between collisions can be selected by three$/;"	v
freepath_csg	iran3d_all.c	/^void freepath_csg (int projZ, int projM, float *energy, double flight_length, double *step,$/;"	f
freepath_fetm	iran3d_all.c	/^void freepath_fetm (double *x, double *y, double *z, double *vx, double *vy, double *vz,$/;"	f
func_x0	iran3d_all.c	/^double func_x0 (double x0, double epsilon, double s) {$/;"	f
gauss_random_list	iran3d_all.c	/^float gauss_random_list[MAXRANLIST];  \/* Gauss distribution randomlist, ygli *\/$/;"	v
gen_shape_or_not	iran3d_all.c	/^int gen_shape_or_not;  \/* 1 - generate fetm shape file for fetm geometry *\/$/;"	v
generate_fetm_tri_shape	iran3d_all.c	/^int generate_fetm_tri_shape (void) {$/;"	f
geometry_type	iran3d_all.c	/^int geometry_type;     \/* 0 - CSG, 1 - FETM *\/$/;"	v
get_cell_index	iran3d_all.c	/^int get_cell_index (double x, double y, double z, int *cell_i) {$/;"	f
get_float_one_bit_smaller	iran3d_all.c	/^void get_float_one_bit_smaller (float *flt_input, float *flt_output) {$/;"	f
get_leaving_direction	iran3d_all.c	/^int get_leaving_direction (double vx, double vy, double vz) {$/;"	f
get_relative_XYZ	iran3d_all.c	/^void get_relative_XYZ (int x, int y, int z, float *rx, float *ry, float *rz) {$/;"	f
get_target_XYZ	iran3d_all.c	/^void get_target_XYZ (int index, int *x, int *y, int *z) {$/;"	f
get_target_index	iran3d_all.c	/^int get_target_index (int x, int y, int z) {$/;"	f
handle_cmd_line_options	iran3d_all.c	/^int handle_cmd_line_options (int argc, char *argv[]) {$/;"	f
headerRef	iran3d_all.c	/^float headerRef[HEADERSIZE] = {MINE, DIME, MAXE, MINS, DIMS, MAXS, NSUM};$/;"	v
hydrogen_in_target	iran3d_all.c	/^int hydrogen_in_target;                 \/* Hydrogen is always included in the existing_elements_list,$/;"	v
hyperboloid_AA	iran3d_all.c	/^double hyperboloid_AA[20];$/;"	v
hyperboloid_BB	iran3d_all.c	/^double hyperboloid_BB[20];$/;"	v
hyperboloid_RR	iran3d_all.c	/^double hyperboloid_RR[20];$/;"	v
hyperboloid_distance	iran3d_all.c	/^double hyperboloid_distance[20];$/;"	v
hyperboloid_height	iran3d_all.c	/^double hyperboloid_height[20];$/;"	v
hyperboloid_intersect	iran3d_all.c	/^int hyperboloid_intersect (int seq, double TT[]) {$/;"	f
hyperboloid_radius	iran3d_all.c	/^double hyperboloid_radius[20];$/;"	v
ignoreline	iran3d_all.c	/^void ignoreline (FILE *ifp) {$/;"	f
init_H	iran3d_all.c	601;"	d	file:
init_configuration	iran3d_all.c	/^int init_configuration (char *ConfigFileName) {$/;"	f
init_materials	iran3d_all.c	/^int init_materials (char *file_name) {$/;"	f
init_target_structure	iran3d_all.c	/^int init_target_structure (char *file_name) {$/;"	f
int_c	iran3d_all.c	/^int int_c;              \/* interstitial *\/$/;"	v
interface_path	iran3d_all.c	/^void interface_path (int s_count, double sect[][3], double *s, int projZ,$/;"	f
inv_screening_length	iran3d_all.c	/^    float inv_screening_length;  \/* 1\/screening length in 1\/nm *\/$/;"	m	struct:scattering_matrix	file:
inv_sqrt	iran3d_all.c	/^float inv_sqrt (float val) {$/;"	f
inv_sqrt_log_list	iran3d_all.c	/^float inv_sqrt_log_list[MAXLOGLIST];  \/* 1\/sqrtloglist *\/$/;"	v
inv_sqrt_table	iran3d_all.c	/^float inv_sqrt_table[1<<16];$/;"	v
inv_sqrt_table_exp	iran3d_all.c	/^float inv_sqrt_table_exp[256];$/;"	v
inverse_erf_list	iran3d_all.c	/^float inverse_erf_list[MAXERFLIST];  \/* list of evenly distributed but randomly ordered$/;"	v
ionZ_in_target	iran3d_all.c	/^int ionZ_in_target;                     \/* The ion is always included in the existing_elements_list.$/;"	v
ion_M	iran3d_all.c	/^float ion_M;                  \/* mass of the ion *\/$/;"	v
ion_Z	iran3d_all.c	/^int   ion_Z;                  \/* proton number *\/$/;"	v
ion_c	iran3d_all.c	/^int ion_c;              \/* ion *\/$/;"	v
ion_distribution	iran3d_all.c	/^int   ion_distribution;      \/* 0 for random ion entry positions,$/;"	v
ion_initial_energy	iran3d_all.c	/^float ion_initial_energy;     \/* impinging energy *\/$/;"	v
ion_paths_fp	iran3d_all.c	/^FILE *ion_paths_fp;         \/* the file with the ion paths will be open all the time if the paths$/;"	v
ion_scattering_matrix	iran3d_all.c	/^struct scattering_matrix ion_scattering_matrix[MAX_ELEMENT_NO];$/;"	v	typeref:struct:scattering_matrix
ion_surf_energy	iran3d_all.c	/^    float ion_surf_energy;                \/* Surface binding energy of the ion in this material.$/;"	m	struct:material	file:
ion_vx	iran3d_all.c	/^float ion_vx;                \/* vector of ion velocity, normalized to 1 *\/$/;"	v
ion_vy	iran3d_all.c	/^float ion_vy;                \/* Note, that the ion is NOT described by its actual velocity vector, *\/$/;"	v
ion_vz	iran3d_all.c	/^float ion_vz;                \/* but by the flying direction vector of length 1 and its energy. *\/$/;"	v
irradiate_target	iran3d_all.c	/^int irradiate_target (void) {$/;"	f
is_full	iran3d_all.c	/^int is_full[20];     \/* materials in shape elements *\/$/;"	v
juintersect	iran3d_all.c	/^int juintersect (double *x, double *y, double *z, double vx, double vy, double vz) {$/;"	f
kfactor_m	iran3d_all.c	/^    float kfactor_m;             \/* mass part of the kinematic factor.$/;"	m	struct:scattering_matrix	file:
layer_count_yz	iran3d_all.c	/^int layer_count_yz;    \/* layer_count_xy = cell_count_x * cell_count_y,$/;"	v
layer_distance	iran3d_all.c	/^    float layer_distance;       \/* layer distcance assuming simple cubic structure[nm] *\/$/;"	m	struct:material	file:
leaving_ions	iran3d_all.c	/^int leaving_ions[8];        \/* number of ions, leaving target in each direction\/quadrants, ygli *\/$/;"	v
leaving_ions_c	iran3d_all.c	/^int leaving_ions_c;     \/* *\/$/;"	v
leaving_recoils_c	iran3d_all.c	/^int leaving_recoils_c;  \/* *\/$/;"	v
leaving_recoils_pointer	iran3d_all.c	/^    int *leaving_recoils_pointer;      \/* array of pointers which for each element of this material$/;"	m	struct:material	file:
line_flag	iran3d_all.c	/^int    line_flag;$/;"	v
list_of_materials	iran3d_all.c	/^struct material list_of_materials[MAX_NO_MATERIALS];$/;"	v	typeref:struct:material
load_Chu_straggling_values	iran3d_all.c	/^int load_Chu_straggling_values () {$/;"	f
load_inverse_Erf	iran3d_all.c	/^int load_inverse_Erf () {$/;"	f
load_matrix	iran3d_all.c	/^int load_matrix (char file_name[]) {$/;"	f
log_list	iran3d_all.c	/^float log_list[MAXLOGLIST];  \/* important modification, sqrt_log_list -> log_list *\/$/;"	v
main	iran3d_all.c	/^int main (int argc, char *argv[]) {$/;"	f
make_float_array	iran3d_all.c	/^int make_float_array (char *values, int count, float *f_array) {$/;"	f
make_int_array	iran3d_all.c	/^int make_int_array (char *values, int count, int *i_array) {$/;"	f
make_line	iran3d_all.c	/^void make_line (double x, double y, double z, double vx,$/;"	f
make_line_tri	iran3d_all.c	/^void make_line_tri (int flag_or_not, double sin_theta, double cos_theta,$/;"	f
mass_ratio	iran3d_all.c	/^    float mass_ratio;            \/* ... *\/$/;"	m	struct:scattering_matrix	file:
mat_mul	iran3d_all.c	/^void mat_mul (double a[], double b[], int m, int n, int k, double c[]) {$/;"	f
mater_type	iran3d_all.c	/^    int   mater_type[800];  \/* material type inside this triangle, 100 -> 800 *\/$/;"	m	struct:GRIDBOX	file:
material	iran3d_all.c	/^int material[20];$/;"	v
material	iran3d_all.c	/^struct material                 \/* all properties of a material *\/$/;"	s	file:
matrix	iran3d_all.c	/^float matrix[DIME*DIMS];$/;"	v
matrix_i	iran3d_all.c	/^float matrix_i (unsigned long i) {$/;"	f
max_annular_coll_volumes	iran3d_all.c	/^int max_annular_coll_volumes;  \/* According to W.Eckstein "Computer Simulation if Ion-Solid$/;"	v
max_loc_abs	iran3d_all.c	/^int max_loc_abs (double a[], int n) {$/;"	f
max_no_ions	iran3d_all.c	/^int   max_no_ions;            \/* maximum number of ions *\/$/;"	v
mean_A	iran3d_all.c	/^    float mean_A;      \/* average A (screening length), weighted by fraction, *\/$/;"	m	struct:material	file:
mean_F	iran3d_all.c	/^    float mean_F;      \/* average F (reduced energy conversion factor), weighted by fraction *\/$/;"	m	struct:material	file:
mean_M	iran3d_all.c	/^    float mean_M;      \/* average M, weighted by fraction *\/$/;"	m	struct:material	file:
mean_Z	iran3d_all.c	/^    float mean_Z;      \/* average Z, weighted by fraction *\/$/;"	m	struct:material	file:
mean_impact_par	iran3d_all.c	/^    float mean_impact_par;         \/* not actually the mean impact paramater but rather$/;"	m	struct:material	file:
mean_min_red_transfer	iran3d_all.c	/^    float mean_min_red_transfer;  \/* average minimun energy transfer in reduced units *\/$/;"	m	struct:material	file:
mem_usage	iran3d_all.c	/^unsigned long int mem_usage;   \/* if mem_usage active, then sum it up here (in bytes) *\/$/;"	v
mem_usage_details	iran3d_all.c	/^int mem_usage_details;         \/* if 1, print more details for memory usage *\/$/;"	v
mem_usage_only	iran3d_all.c	/^int mem_usage_only;            \/* if 1, then do not simulate anything, just estimate memory usage *\/$/;"	v
min_energy	iran3d_all.c	/^float min_energy;            \/* minimum energy below which all projectiles are stopped *\/$/;"	v
miss_c	iran3d_all.c	/^int miss_c;             \/* missed collision *\/$/;"	v
most_abundant_isotope	iran3d_all.c	/^float most_abundant_isotope[NUMBERELEMENTS];$/;"	v
most_abundant_isotope	iran3d_all.c	/^float most_abundant_isotope[] = { 92,$/;"	v
my_shape	iran3d_all.c	/^int my_shape[20];    \/* indexes of shape elements *\/$/;"	v
name	iran3d_all.c	/^    char  name[50];             \/* a name can be defined *\/$/;"	m	struct:material	file:
normalize_output	iran3d_all.c	/^int normalize_output;          \/* if 1, the output of the program will be normalized to$/;"	v
num_of_data	iran3d_all.c	/^int num_of_data[20];$/;"	v
num_of_material	iran3d_all.c	/^int num_of_material;$/;"	v
num_triangles	iran3d_all.c	/^    int   num_triangles;    \/* number of triangles in this box *\/$/;"	m	struct:GRIDBOX	file:
number_of_all_target_elements	iran3d_all.c	/^int    number_of_all_target_elements;  \/* without ion. *\/$/;"	v
number_of_materials	iran3d_all.c	/^int    number_of_materials;            \/* points to first free index in the ListOfMaterials *\/$/;"	v
open_file_continuous	iran3d_all.c	/^FILE *open_file_continuous (char *base_name, char *extension) {$/;"	f
orientation	iran3d_all.c	/^double orientation[20][3][3];$/;"	v
output_format	iran3d_all.c	/^int output_format;             \/* if 1, iradiana output format; if 2, cfg output_format *\/$/;"	v
override_energy	iran3d_all.c	/^float  override_energy;         \/* for command-line argument override of ion energy *\/$/;"	v
override_max_ions	iran3d_all.c	/^int    override_max_ions;       \/* for command-line argument override of maximum number of ions *\/$/;"	v
paraboloid_RR	iran3d_all.c	/^double paraboloid_RR[20];$/;"	v
paraboloid_RRH	iran3d_all.c	/^double paraboloid_RRH[20];$/;"	v
paraboloid_height	iran3d_all.c	/^double paraboloid_height[20];$/;"	v
paraboloid_intersect	iran3d_all.c	/^int paraboloid_intersect (int seq, double TT[]) {$/;"	f
paraboloid_radius	iran3d_all.c	/^double paraboloid_radius[20];$/;"	v
phi_LJ	iran3d_all.c	/^double phi_LJ (double x) {$/;"	f
phi_none	iran3d_all.c	/^double phi_none (double x) {$/;"	f
phi_univ	iran3d_all.c	/^double phi_univ (double x) {$/;"	f
plane2_intersect	iran3d_all.c	/^int plane2_intersect (double N[], double LVO, double D[], double T2[]) {$/;"	f
point	iran3d_all.c	/^double point[20][4][3];$/;"	v
polygon_Cnt	iran3d_all.c	/^int polygon_Cnt[20];$/;"	v
polygon_intersect	iran3d_all.c	/^int polygon_intersect (double PTmp[][3], int Cnt, double P0[]) {$/;"	f
polygon_vertex	iran3d_all.c	/^double polygon_vertex[20][20][20][3];$/;"	v
polyhedron_intersect	iran3d_all.c	/^int polyhedron_intersect (int seq, double TT[]) {$/;"	f
prepare_scattering_matrix	iran3d_all.c	/^int prepare_scattering_matrix (struct scattering_matrix *scat_matrix, float proj_M,$/;"	f
prepare_stopping_tables	iran3d_all.c	/^int prepare_stopping_tables (void) {$/;"	f
prepare_straggling_tables	iran3d_all.c	/^int prepare_straggling_tables (int model) {$/;"	f
print_help_text	iran3d_all.c	/^int print_help_text (void) {$/;"	f
print_level	iran3d_all.c	/^int print_level;               \/* determines how much stuff is printed to the console$/;"	v
projectile_transport	iran3d_all.c	/^int projectile_transport (int projZ, float projM, float projE, double proj_x,$/;"	f
ran_list	iran3d_all.c	/^unsigned int ran_list;          \/* points to next entry in the random list *\/$/;"	v
ran_log_list	iran3d_all.c	/^unsigned int ran_log_list;      \/* points to next entry in the random sqrt logarithmic list *\/$/;"	v
random_list	iran3d_all.c	/^float random_list[MAXRANLIST];$/;"	v
randomize_list	iran3d_all.c	/^void randomize_list (float *list, unsigned int max_list) {$/;"	f
randomx	iran3d_all.c	/^double randomx (void) {$/;"	f
read_config_file_data	iran3d_all.c	/^int read_config_file_data (char *par_name, char *par_value) {$/;"	f
read_config_file_data_block	iran3d_all.c	/^int read_config_file_data_block (char *block_name) {$/;"	f
read_csg_shape	iran3d_all.c	/^int read_csg_shape (char *file_name) {$/;"	f
read_fetm_shape	iran3d_all.c	/^int read_fetm_shape (char *file_name) {$/;"	f
read_file_opengl	iran3d_all.c	/^int read_file_opengl (int n, int num_of_data) {$/;"	f
read_file_ply2	iran3d_all.c	/^int read_file_ply2 (int n) {$/;"	f
read_float_block	iran3d_all.c	/^int read_float_block (char *file_name, int offset, int count, float *array) {$/;"	f
read_init_file	iran3d_all.c	/^int read_init_file (int (*read_data_block) (char *block_name),$/;"	f
read_materials_data	iran3d_all.c	/^int read_materials_data (char *par_name, char *par_value) {$/;"	f
read_materials_data_block	iran3d_all.c	/^int read_materials_data_block (char *material_name) {$/;"	f
read_rotation	iran3d_all.c	/^int read_rotation (int i, double *ax, double *ay, double *az) {$/;"	f
read_scaling	iran3d_all.c	/^int read_scaling (int i) {$/;"	f
read_shearing	iran3d_all.c	/^int read_shearing (int i) {$/;"	f
read_target_structure_data	iran3d_all.c	/^int read_target_structure_data (char *par_name, char *par_value) {$/;"	f
read_target_structure_data_block	iran3d_all.c	/^int read_target_structure_data_block (char *block_name) {$/;"	f
read_translation	iran3d_all.c	/^int read_translation (int i) {$/;"	f
recoil_cascades_fp	iran3d_all.c	/^FILE *recoil_cascades_fp;   \/* the file with the recoil cascades will be open all the time if the$/;"	v
red_E_conv	iran3d_all.c	/^    float red_E_conv;            \/* reduced energy conversion factor. This is called FI in TRIM *\/$/;"	m	struct:scattering_matrix	file:
refract_projectile2	iran3d_all.c	/^int refract_projectile2 (double *vx, double *vy, double *vz, double nx, double ny,$/;"	f
refraction	iran3d_all.c	/^void refraction (double NT[], double *vx, double *vy, double *vz, int *S_flag,$/;"	f
repl_c	iran3d_all.c	/^int repl_c;             \/* replacement *\/$/;"	v
rev_atomic_distance	iran3d_all.c	/^    float rev_atomic_distance;  \/* 1.0\/AtomicDistance [nm^-1], ygli *\/$/;"	m	struct:material	file:
rotate	iran3d_all.c	/^void rotate (double *l, double *m, double *n, unsigned int *iazim_angle,$/;"	f
rx	iran3d_all.c	/^double rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
rxyz	iran3d_all.c	/^double rxyz[20][3][3];$/;"	v
ry	iran3d_all.c	/^double rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
rz	iran3d_all.c	/^double rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
s_count	iran3d_all.c	/^int s_count;         \/* number of shape elements *\/$/;"	v
scaling	iran3d_all.c	/^double scaling[20][3];$/;"	v
scaling_x	iran3d_all.c	/^double scaling_x, scaling_y, scaling_z;$/;"	v
scaling_y	iran3d_all.c	/^double scaling_x, scaling_y, scaling_z;$/;"	v
scaling_z	iran3d_all.c	/^double scaling_x, scaling_y, scaling_z;$/;"	v
scattering_calculation	iran3d_all.c	/^int scattering_calculation;     \/* 0: corteo database, 1: MAGIC  *\/$/;"	v
scattering_matrices	iran3d_all.c	/^struct scattering_matrix scattering_matrices[MAX_ELEMENT_NO][MAX_ELEMENT_NO];$/;"	v	typeref:struct:scattering_matrix
scattering_matrix	iran3d_all.c	/^struct scattering_matrix  \/* This structure holds information for a scattering events of two$/;"	s	file:
screening_length	iran3d_all.c	/^    float screening_length;      \/* screening length from ZBL85,p45, eq.2-60, but in [nm] *\/$/;"	m	struct:scattering_matrix	file:
screening_type	iran3d_all.c	678;"	d	file:
sect_sort	iran3d_all.c	/^void sect_sort (int *n, double sect[]) {$/;"	f
seed1	iran3d_all.c	/^int seed1, seed2;$/;"	v
seed2	iran3d_all.c	/^int seed1, seed2;$/;"	v
set_matrix	iran3d_all.c	/^void set_matrix (unsigned long i, float val) {$/;"	f
shearing	iran3d_all.c	/^double shearing[20][3][3];$/;"	v
shift	iran3d_all.c	/^double shift[20][3];$/;"	v
simulation_type	iran3d_all.c	/^int simulation_type;  \/* How to do the simulation.$/;"	v
sin_azim_angle	iran3d_all.c	/^float sin_azim_angle[MAXAZILIST];  \/* list cos and sin components of angles... *\/$/;"	v
sin_scat	iran3d_all.c	/^    float *sin_scat;             \/* sines of scattering angles, for each energy and p *\/$/;"	m	struct:scattering_matrix	file:
single_input_file	iran3d_all.c	/^int single_input_file;  \/* if 0, then multiple files (normal).$/;"	v
single_ion_sputter_counter	iran3d_all.c	/^int single_ion_sputter_counter;$/;"	v
single_ion_sputter_yields	iran3d_all.c	/^int single_ion_sputter_yields;  \/* if 1, iradina will store sputter yields for single ions$/;"	v
sphere_C	iran3d_all.c	/^double sphere_C[20][3];$/;"	v
sphere_R2	iran3d_all.c	/^double sphere_R2[20];$/;"	v
sphere_intersect	iran3d_all.c	/^int sphere_intersect (int seq, double TT[]) {$/;"	f
split_single_input_file	iran3d_all.c	/^int split_single_input_file (char *file_name) {$/;"	f
sputter_c	iran3d_all.c	/^int sputter_c;          \/* sputtering *\/$/;"	v
sputter_counter	iran3d_all.c	/^    int   sputter_counter[MAX_EL_PER_MAT*8];  \/* count sputtered atoms leaving the sample in each$/;"	m	struct:material	file:
sputter_yield_histogram	iran3d_all.c	/^int *sputter_yield_histogram;   \/* array that stores single ion sputter yield histogram *\/$/;"	v
sqrt_mass_ratio	iran3d_all.c	/^    float sqrt_mass_ratio;       \/* we will need this occasionally *\/$/;"	m	struct:scattering_matrix	file:
sqrt_random_list	iran3d_all.c	/^float sqrt_random_list[MAXRANLIST];   \/* sqrt of randomlist *\/$/;"	v
sqrt_rec_fl_density	iran3d_all.c	/^    float sqrt_rec_fl_density;     \/* 1\/sqrt(pi*flight_length_constant*density) needed for$/;"	m	struct:material	file:
sqrt_table	iran3d_all.c	/^float sqrt_table[1<<16];$/;"	v
sqrt_table_exp	iran3d_all.c	/^float sqrt_table_exp[256];$/;"	v
sqrtdf	iran3d_all.c	/^float sqrtdf (double val) {$/;"	f
start_id_string	iran3d_all.c	/^char *start_id_string;         \/* string that helps other programs to identify iran3d output *\/$/;"	v
status_update_interval	iran3d_all.c	/^int    status_update_interval;  \/* After so many ions, the status is written to the status file$/;"	v
stopping_ZE	iran3d_all.c	/^    float **stopping_ZE;                \/* points to an array of 92 elements (the Zs) which contain$/;"	m	struct:material	file:
storage_interval	iran3d_all.c	/^int    storage_interval;        \/* dump the target arrays into the files every such number of ions *\/$/;"	v
store_depth_dist_array	iran3d_all.c	/^int store_depth_dist_array (char *file_name) {$/;"	f
store_energy_deposit	iran3d_all.c	/^int store_energy_deposit;  \/* if 1, array with deposited energy are created and stored;$/;"	v
store_exiting_limit	iran3d_all.c	/^int store_exiting_limit;     \/* maximum number of exiting recoils to be stored *\/$/;"	v
store_exiting_recoils	iran3d_all.c	/^int store_exiting_recoils;   \/* 1 if all exiting recoils should be stored *\/$/;"	v
store_ion_paths	iran3d_all.c	/^int store_ion_paths;  \/* 1 if the exact paths should be stored (interesting for debugging stuff *\/$/;"	v
store_path_limit	iran3d_all.c	/^int store_path_limit;        \/* only for so many ions, the exact paths and recoil cascades are stored *\/$/;"	v
store_recoil_cascades	iran3d_all.c	/^int store_recoil_cascades;  \/* 1 if the exact recoils cascades should be stored$/;"	v
store_results_cfg	iran3d_all.c	/^int store_results_cfg (char *base_name) {$/;"	f
store_results_iradina	iran3d_all.c	/^int store_results_iradina (char *base_name) {$/;"	f
store_transmission_array	iran3d_all.c	/^int store_transmission_array (char *file_name, struct transmitted_ion *trans_array,$/;"	f
store_transmitted_ions	iran3d_all.c	/^int store_transmitted_ions;  \/* 1 if true *\/$/;"	v
straggling_ZE	iran3d_all.c	/^    float **straggling_ZE;              \/* we need the same for energy loss straggling *\/$/;"	m	struct:material	file:
straggling_model	iran3d_all.c	/^int straggling_model;       \/* how to calc straggling *\/$/;"	v
sub_surf_z	iran3d_all.c	/^float sub_surf_z;      \/* z coordinate of the half-infinite substrate surface in nm *\/$/;"	v
sum_array	iran3d_all.c	/^ double sum_array (double a[], int num_elements) {$/;"	f
sum_up_material_arrays	iran3d_all.c	/^void sum_up_material_arrays (void) {$/;"	f
taper_TgT2	iran3d_all.c	/^double taper_TgT2[20];$/;"	v
taper_height	iran3d_all.c	/^double taper_height[20];$/;"	v
taper_intersect	iran3d_all.c	/^int taper_intersect (int seq, double TT[]) {$/;"	f
target_composition	iran3d_all.c	/^int   *target_composition;          \/* material of each cell *\/$/;"	v
target_composition_file_type	iran3d_all.c	/^int target_composition_file_type;   \/* The file which hold the info of what material is in$/;"	v
target_depth_elemental_disp	iran3d_all.c	/^    int **target_depth_elemental_disp;$/;"	m	struct:material	file:
target_depth_elemental_vacancies	iran3d_all.c	/^    int **target_depth_elemental_vacancies;$/;"	m	struct:material	file:
target_depth_energy_electrons	iran3d_all.c	/^double *target_depth_energy_electrons;$/;"	v
target_depth_energy_phonons	iran3d_all.c	/^double *target_depth_energy_phonons;$/;"	v
target_depth_implanted_ions	iran3d_all.c	/^int   *target_depth_implanted_ions;$/;"	v
target_depth_implanted_recoils_int	iran3d_all.c	/^    int **target_depth_implanted_recoils_int;$/;"	m	struct:material	file:
target_depth_implanted_recoils_repl	iran3d_all.c	/^    int **target_depth_implanted_recoils_repl;$/;"	m	struct:material	file:
target_depth_replacing_ions	iran3d_all.c	/^int   *target_depth_replacing_ions;$/;"	v
target_depth_total_displacements	iran3d_all.c	/^int   *target_depth_total_displacements;$/;"	v
target_depth_total_interstitials	iran3d_all.c	/^int   *target_depth_total_interstitials;$/;"	v
target_depth_total_replacements	iran3d_all.c	/^int   *target_depth_total_replacements;$/;"	v
target_depth_total_vacancies	iran3d_all.c	/^int   *target_depth_total_vacancies;$/;"	v
target_elemental_disp	iran3d_all.c	/^    int **target_elemental_disp;         \/* displacements of this element that took place *\/$/;"	m	struct:material	file:
target_elemental_vacancies	iran3d_all.c	/^    int **target_elemental_vacancies;    \/* vacancies of this element left behind *\/$/;"	m	struct:material	file:
target_energy_electrons	iran3d_all.c	/^double *target_energy_electrons;    \/* all energy deposited by electronic stopping.$/;"	v
target_energy_phonons	iran3d_all.c	/^double *target_energy_phonons;      \/* all energy deposited into the phononic system *\/$/;"	v
target_implanted_ions	iran3d_all.c	/^int   *target_implanted_ions;       \/* implanted ions per cell (interstitials+replacements) *\/$/;"	v
target_implanted_recoils_int	iran3d_all.c	/^    int **target_implanted_recoils_int;   \/* the implanted recoils stopped as interstitials *\/$/;"	m	struct:material	file:
target_implanted_recoils_repl	iran3d_all.c	/^    int **target_implanted_recoils_repl;  \/* the implanted recoils stopped as replacement atoms *\/$/;"	m	struct:material	file:
target_max_x	iran3d_all.c	/^float target_max_x;    \/* maximum allowed position in x-direction in nm *\/$/;"	v
target_max_y	iran3d_all.c	/^float target_max_y;    \/* these positions are the largest possible values, *\/$/;"	v
target_max_z	iran3d_all.c	/^float target_max_z;    \/* which are smaller target_size_x etc. *\/$/;"	v
target_replacing_ions	iran3d_all.c	/^int   *target_replacing_ions;       \/* implanted ions that replaced identical target atoms *\/$/;"	v
target_size_x	iran3d_all.c	/^float target_size_x;   \/* size of target in x-direction in nm *\/$/;"	v
target_size_y	iran3d_all.c	/^float target_size_y;   \/* they are calculated *\/$/;"	v
target_size_z	iran3d_all.c	/^float target_size_z;$/;"	v
target_sputtered_atoms	iran3d_all.c	/^    int **target_sputtered_atoms;        \/* number of atoms sputtered from this cell *\/$/;"	m	struct:material	file:
target_total_displacements	iran3d_all.c	/^int   *target_total_displacements;  \/* displacements per cell (of all types) *\/ \/* Disp = Vac + Repl *\/$/;"	v
target_total_interstitials	iran3d_all.c	/^int   *target_total_interstitials;  \/* sum of interstitials per cell (of all recoil$/;"	v
target_total_replacements	iran3d_all.c	/^int   *target_total_replacements;   \/* replacements per cell (of all types) *\/$/;"	v
target_total_sputtered	iran3d_all.c	/^int  *target_total_sputtered;       \/* sum of sputtered atoms from each cell *\/$/;"	v
target_total_vacancies	iran3d_all.c	/^int   *target_total_vacancies;      \/* vacancies per cell (of all types) *\/$/;"	v
tetrahedron_intersect	iran3d_all.c	/^int tetrahedron_intersect (int seq, double TT[]) {$/;"	f
total_sputter_counter	iran3d_all.c	/^int total_sputter_counter[8];       \/* number of target atoms leaving the sample in each of the$/;"	v
trans_TT	iran3d_all.c	/^void trans_TT (int seq, double TT[]) {$/;"	f
transmission	iran3d_all.c	/^void transmission (double uz, int idied, float energy, float U0) {$/;"	f
transmission_pointer	iran3d_all.c	/^int transmission_pointer;    \/* point to next free index in array *\/$/;"	v
transmit_list	iran3d_all.c	/^struct transmitted_ion *transmit_list;  \/* list of transmitted ions *\/$/;"	v	typeref:struct:transmitted_ion
transmitted_ion	iran3d_all.c	/^struct transmitted_ion       \/* describes an ion that has been transmitted (left the target) *\/$/;"	s	file:
transport_type	iran3d_all.c	/^int transport_type;             \/* 0: accurate, 1: Fast (like corteo) *\/$/;"	v
triangle	iran3d_all.c	/^double **triangle;$/;"	v
triangle_intersect_csg	iran3d_all.c	/^int triangle_intersect_csg (double P[][3], double *temp, int *flag) {$/;"	f
triangle_intersect_fetm	iran3d_all.c	/^int triangle_intersect_fetm (double trix1, double triy1, double triz1, double trix2,$/;"	f
unit_conversion_factor	iran3d_all.c	/^double unit_conversion_factor; \/* This converts output to unit of (1\/cm^3)per(1\/cm^2) *\/$/;"	v
update_xyz	iran3d_all.c	/^void update_xyz (double *x, double *y, double *z, double vx, double vy, double vz, double s) {$/;"	f
use_density_mult	iran3d_all.c	/^int   use_density_mult;             \/* 0 if multiplicators not used, 1 if used *\/$/;"	v
vac_c	iran3d_all.c	/^int vac_c;              \/* vacancy *\/$/;"	v
vertex_Cnt	iran3d_all.c	/^int vertex_Cnt[20][20];$/;"	v
vx	iran3d_all.c	/^    double vx;                \/* exit velocity unit vector *\/$/;"	m	struct:transmitted_ion	file:
vy	iran3d_all.c	/^    double vy;$/;"	m	struct:transmitted_ion	file:
vz	iran3d_all.c	/^    double vz;$/;"	m	struct:transmitted_ion	file:
wait_before_end	iran3d_all.c	/^int wait_before_end;           \/* if 1, the program only quits after pressing return key *\/$/;"	v
write_double_array_to_cfg_file	iran3d_all.c	/^int write_double_array_to_cfg_file (char *file_name, double *source_array1,$/;"	f
write_double_array_to_file	iran3d_all.c	/^int write_double_array_to_file (char *file_name, double *source_array, int count, int file_type) {$/;"	f
write_int_array_to_cfg_file	iran3d_all.c	/^int write_int_array_to_cfg_file (char *file_name, int mat_i, int *source_array_total,$/;"	f
write_int_array_to_file	iran3d_all.c	/^int write_int_array_to_file (char *file_name, int *source_array, int count, int file_type) {$/;"	f
write_rotation	iran3d_all.c	/^int write_rotation (int i, double ax, double ay, double az) {$/;"	f
write_shear_scale	iran3d_all.c	/^int write_shear_scale (int i) {$/;"	f
write_status_file	iran3d_all.c	/^int write_status_file (char *status_text, int ion_number) {$/;"	f
write_string_to_file	iran3d_all.c	/^int write_string_to_file (char *file_name, char *str) {$/;"	f
write_translation	iran3d_all.c	/^int write_translation (int i) {$/;"	f
x	iran3d_all.c	/^    double x;                 \/* exit position x *\/$/;"	m	struct:transmitted_ion	file:
xyz_flag	iran3d_all.c	/^double xyz_flag;$/;"	v
y	iran3d_all.c	/^    double y;                 \/* y *\/$/;"	m	struct:transmitted_ion	file:
z	iran3d_all.c	/^    double z;                 \/* z *\/$/;"	m	struct:transmitted_ion	file:
z0_max	iran3d_all.c	/^float z0_max;$/;"	v
BIASD	iran3d_all_140429.c	5005;"	d	file:
BIASD	iran3d_all_140429.c	5024;"	d	file:
BIASE	iran3d_all_140429.c	4993;"	d	file:
BIASE	iran3d_all_140429.c	5012;"	d	file:
BIASS	iran3d_all_140429.c	4999;"	d	file:
BIASS	iran3d_all_140429.c	5018;"	d	file:
CONST_H	iran3d_all_140429.c	481;"	d	file:
CSG_H	iran3d_all_140429.c	7125;"	d	file:
ConfigFileName	iran3d_all_140429.c	/^char *ConfigFileName;          \/* name of the general input config file *\/$/;"	v
ConversionFileName	iran3d_all_140429.c	/^char *ConversionFileName;      \/* name of the converted input file (when converting from$/;"	v
DIMD	iran3d_all_140429.c	5004;"	d	file:
DIMD	iran3d_all_140429.c	5023;"	d	file:
DIME	iran3d_all_140429.c	4992;"	d	file:
DIME	iran3d_all_140429.c	5011;"	d	file:
DIMS	iran3d_all_140429.c	4998;"	d	file:
DIMS	iran3d_all_140429.c	5017;"	d	file:
D_TO_R	iran3d_all_140429.c	486;"	d	file:
D_index	iran3d_all_140429.c	/^unsigned long D_index (float D_val) {$/;"	f
D_max_err	iran3d_all_140429.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
D_min_err	iran3d_all_140429.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
D_val	iran3d_all_140429.c	/^float D_val (unsigned long index) {$/;"	f
E2	iran3d_all_140429.c	489;"	d	file:
E_index	iran3d_all_140429.c	/^unsigned long E_index (float E_val) {$/;"	f
E_max_err	iran3d_all_140429.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
E_min_err	iran3d_all_140429.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
E_val	iran3d_all_140429.c	/^float E_val (unsigned long index) {$/;"	f
ElementsFileName	iran3d_all_140429.c	/^char *ElementsFileName;        \/* name of the file that defines the elements in the target$/;"	v
FETM_H	iran3d_all_140429.c	9119;"	d	file:
FILEIO_H	iran3d_all_140429.c	5269;"	d	file:
GBOX	iran3d_all_140429.c	/^    float GBOX[800][9];     \/* triangle vertex coordinates *\/$/;"	m	struct:GRIDBOX	file:
GRB	iran3d_all_140429.c	/^struct GRIDBOX ***GRB;$/;"	v	typeref:struct:GRIDBOX
GRIDBOX	iran3d_all_140429.c	/^struct GRIDBOX  \/* geometry *\/$/;"	s	file:
H	iran3d_all_140429.c	/^double H (double u, double x0, double epsilon, double s) {$/;"	f
HEADERSIZE	iran3d_all_140429.c	4467;"	d	file:
INDEX_BOUND_CHECKING	iran3d_all_140429.c	4982;"	d	file:
INDEX_H	iran3d_all_140429.c	4979;"	d	file:
IRAN3D_H	iran3d_all_140429.c	16;"	d	file:
LO	iran3d_all_140429.c	/^double LV[3], LO[3];$/;"	v
LO1	iran3d_all_140429.c	/^double LV1[3], LO1[3];$/;"	v
LV	iran3d_all_140429.c	/^double LV[3], LO[3];$/;"	v
LV1	iran3d_all_140429.c	/^double LV1[3], LO1[3];$/;"	v
MATERIAL_H	iran3d_all_140429.c	1115;"	d	file:
MATRIX_H	iran3d_all_140429.c	4369;"	d	file:
MAX	iran3d_all_140429.c	11676;"	d	file:
MAXAZILIST	iran3d_all_140429.c	12454;"	d	file:
MAXD	iran3d_all_140429.c	5003;"	d	file:
MAXD	iran3d_all_140429.c	5022;"	d	file:
MAXE	iran3d_all_140429.c	4991;"	d	file:
MAXE	iran3d_all_140429.c	5010;"	d	file:
MAXERFLIST	iran3d_all_140429.c	625;"	d	file:
MAXLOGLIST	iran3d_all_140429.c	12453;"	d	file:
MAXRANLIST	iran3d_all_140429.c	12455;"	d	file:
MAXS	iran3d_all_140429.c	4997;"	d	file:
MAXS	iran3d_all_140429.c	5016;"	d	file:
MAX_ELEMENT_NO	iran3d_all_140429.c	1145;"	d	file:
MAX_ELEMENT_NO	iran3d_all_140429.c	4394;"	d	file:
MAX_EL_PER_MAT	iran3d_all_140429.c	1143;"	d	file:
MAX_FILENAME_LENGTH	iran3d_all_140429.c	66;"	d	file:
MAX_NO_MATERIALS	iran3d_all_140429.c	1144;"	d	file:
MAX_SPUTTERED	iran3d_all_140429.c	3094;"	d	file:
MAX_STOPPING_ENTRIES	iran3d_all_140429.c	2215;"	d	file:
MIND	iran3d_all_140429.c	5002;"	d	file:
MIND	iran3d_all_140429.c	5021;"	d	file:
MINE	iran3d_all_140429.c	4990;"	d	file:
MINE	iran3d_all_140429.c	5009;"	d	file:
MINS	iran3d_all_140429.c	4996;"	d	file:
MINS	iran3d_all_140429.c	5015;"	d	file:
MaterialsFileName	iran3d_all_140429.c	/^char *MaterialsFileName;       \/* name of the file that defines the materials in the target *\/$/;"	v
NSUM	iran3d_all_140429.c	4461;"	d	file:
NSUM2	iran3d_all_140429.c	4462;"	d	file:
NUMBERELEMENTS	iran3d_all_140429.c	491;"	d	file:
OutputFileBaseName	iran3d_all_140429.c	/^char *OutputFileBaseName;      \/* all outputfiles begin with this name, so that's put them in a$/;"	v
PHI	iran3d_all_140429.c	/^double (*PHI) (double x);$/;"	v
PI	iran3d_all_140429.c	484;"	d	file:
PROJ_HANGUP_SAFETY	iran3d_all_140429.c	56;"	d	file:
RANDOM_H	iran3d_all_140429.c	12438;"	d	file:
RELEASESTRING	iran3d_all_140429.c	63;"	d	file:
RENORM_VELOCITIES	iran3d_all_140429.c	52;"	d	file:
R_TO_D	iran3d_all_140429.c	485;"	d	file:
R_shearing	iran3d_all_140429.c	/^double R_shearing[20][3][3];$/;"	v
Ro	iran3d_all_140429.c	/^int Ro[20];$/;"	v
SAFE_ROTATION	iran3d_all_140429.c	47;"	d	file:
SAFE_SQR_ROTATION	iran3d_all_140429.c	48;"	d	file:
SCREENCONST	iran3d_all_140429.c	488;"	d	file:
SHIFTD	iran3d_all_140429.c	5006;"	d	file:
SHIFTD	iran3d_all_140429.c	5025;"	d	file:
SHIFTE	iran3d_all_140429.c	4994;"	d	file:
SHIFTE	iran3d_all_140429.c	5013;"	d	file:
SHIFTS	iran3d_all_140429.c	5000;"	d	file:
SHIFTS	iran3d_all_140429.c	5019;"	d	file:
SH_AA	iran3d_all_140429.c	/^double SH_AA[20];$/;"	v
SUBSUBVERSION	iran3d_all_140429.c	62;"	d	file:
SUBVERSION	iran3d_all_140429.c	61;"	d	file:
S_index	iran3d_all_140429.c	/^unsigned long S_index (float S_val) {$/;"	f
S_max_err	iran3d_all_140429.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
S_min_err	iran3d_all_140429.c	/^unsigned long E_min_err, E_max_err, S_min_err, S_max_err, D_min_err, D_max_err;$/;"	v
S_val	iran3d_all_140429.c	/^float S_val (unsigned long index) {$/;"	f
Sc	iran3d_all_140429.c	/^int Sc[20];$/;"	v
Sh	iran3d_all_140429.c	/^int Sh[20];$/;"	v
TARGET_H	iran3d_all_140429.c	2176;"	d	file:
THETAERR	iran3d_all_140429.c	4464;"	d	file:
TRANSPORT_H	iran3d_all_140429.c	2972;"	d	file:
TRIANGULATE_H	iran3d_all_140429.c	10803;"	d	file:
TargetCompositionFileName	iran3d_all_140429.c	/^char *TargetCompositionFileName;$/;"	v
TargetDensityMultFileName	iran3d_all_140429.c	/^char *TargetDensityMultFileName;  \/* *\/$/;"	v
TargetStructureFileName	iran3d_all_140429.c	/^char *TargetStructureFileName; \/* filename of the file that define the structure of the target *\/$/;"	v
Tr	iran3d_all_140429.c	/^int Tr[20];$/;"	v
UTILS_H	iran3d_all_140429.c	11649;"	d	file:
VERSION	iran3d_all_140429.c	60;"	d	file:
VERSIONCOMMENT	iran3d_all_140429.c	64;"	d	file:
VERSIONDATE	iran3d_all_140429.c	59;"	d	file:
a2f	iran3d_all_140429.c	/^float a2f (char *s) {$/;"	f
abc2	iran3d_all_140429.c	/^double abc2[20][3];$/;"	v
add_int_array	iran3d_all_140429.c	/^void add_int_array (int *dest, int *source, int count) {$/;"	f
atomic_distance	iran3d_all_140429.c	/^    float atomic_distance;      \/* average inter-atomic distance [nm] *\/$/;"	m	struct:material	file:
atomic_mass	iran3d_all_140429.c	/^float atomic_mass[NUMBERELEMENTS];  \/* no use *\/$/;"	v
atomic_mass	iran3d_all_140429.c	/^float atomic_mass[] = { 92,$/;"	v
atomic_names	iran3d_all_140429.c	/^char  atomic_names[NUMBERELEMENTS][3];$/;"	v
atomic_names	iran3d_all_140429.c	/^char atomic_names[][3] = { "XX",$/;"	v
ax	iran3d_all_140429.c	/^double ax, ay, az;  \/*  *\/$/;"	v
ay	iran3d_all_140429.c	/^double ax, ay, az;  \/*  *\/$/;"	v
az	iran3d_all_140429.c	/^double ax, ay, az;  \/*  *\/$/;"	v
azim_angle	iran3d_all_140429.c	/^unsigned int azim_angle;        \/* points to next azimutal angle to choose *\/$/;"	v
beam_spread	iran3d_all_140429.c	/^float beam_spread;           \/* in nm, only relevant for option 3 *\/$/;"	v
box_count_x	iran3d_all_140429.c	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_count_y	iran3d_all_140429.c	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_count_z	iran3d_all_140429.c	/^int   box_count_x, box_count_y, box_count_z;  \/* number of box element for a geomentry *\/$/;"	v
box_end_x0	iran3d_all_140429.c	/^float box_end_x0, box_end_y0, box_end_z0;$/;"	v
box_end_y0	iran3d_all_140429.c	/^float box_end_x0, box_end_y0, box_end_z0;$/;"	v
box_end_z0	iran3d_all_140429.c	/^float box_end_x0, box_end_y0, box_end_z0;$/;"	v
box_length_x	iran3d_all_140429.c	/^float box_length_x, box_length_y, box_length_z;$/;"	v
box_length_y	iran3d_all_140429.c	/^float box_length_x, box_length_y, box_length_z;$/;"	v
box_length_z	iran3d_all_140429.c	/^float box_length_x, box_length_y, box_length_z;$/;"	v
box_size_x	iran3d_all_140429.c	/^double box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_size_y	iran3d_all_140429.c	/^double box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_size_z	iran3d_all_140429.c	/^double box_size_x, box_size_y, box_size_z;     \/* size of box element for a geometry *\/$/;"	v
box_start_x0	iran3d_all_140429.c	/^float box_start_x0;    \/* fetm box start point *\/$/;"	v
box_start_y0	iran3d_all_140429.c	/^float box_start_y0;$/;"	v
box_start_z0	iran3d_all_140429.c	/^float box_start_z0;$/;"	v
cal_direct	iran3d_all_140429.c	/^void cal_direct (double xyz[], double *sin_theta, double *cos_theta,$/;"	f
cal_relative_target_atom_position	iran3d_all_140429.c	/^void cal_relative_target_atom_position (double vx, double vy, double vz, double *px,$/;"	f
cal_theta	iran3d_all_140429.c	/^double cal_theta (double epsilon, double s, unsigned int nsum) {$/;"	f
calc_matrix	iran3d_all_140429.c	/^int calc_matrix (unsigned int screening_type, int show_progress, char *file_name) {$/;"	f
calculate_normalization_factor	iran3d_all_140429.c	/^void calculate_normalization_factor (int num_of_ions) {$/;"	f
cell_count	iran3d_all_140429.c	/^    int   cell_count;  \/* number of cells that consist of this material *\/$/;"	m	struct:material	file:
cell_count	iran3d_all_140429.c	/^int cell_count;        \/* total number of cells *\/$/;"	v
cell_count_x	iran3d_all_140429.c	/^int cell_count_x;      \/* number of cells in x-direction (>=1) *\/$/;"	v
cell_count_y	iran3d_all_140429.c	/^int cell_count_y;      \/* number of cells in y-direction (>=1) *\/$/;"	v
cell_count_z	iran3d_all_140429.c	/^int cell_count_z;      \/* number of cells in z-direction (>=1) *\/$/;"	v
cell_size_x	iran3d_all_140429.c	/^float cell_size_x;     \/* size of cells in x-direction in nm *\/$/;"	v
cell_size_y	iran3d_all_140429.c	/^float cell_size_y;     \/* size of cells in y-direction in nm *\/$/;"	v
cell_size_z	iran3d_all_140429.c	/^float cell_size_z;     \/* size of cells in z-direction in nm *\/$/;"	v
cell_volume	iran3d_all_140429.c	/^float cell_volume;     \/* product of the above three *\/$/;"	v
change_axis	iran3d_all_140429.c	/^void change_axis (int seq) {$/;"	f
check_material_type	iran3d_all_140429.c	/^void check_material_type (int *in_or_not, double x, double y, double z, int projZ,$/;"	f
check_split_input_file	iran3d_all_140429.c	/^int check_split_input_file (char *file_name) {$/;"	f
check_surf_bind	iran3d_all_140429.c	/^float check_surf_bind (int current_material_index, int projZ) {$/;"	f
check_target_type_csg	iran3d_all_140429.c	/^int check_target_type_csg (double flight_length) {$/;"	f
check_target_type_fetm	iran3d_all_140429.c	/^int check_target_type_fetm (double x, double y, double z, double vx, double vy, double vz,$/;"	f
chu_values	iran3d_all_140429.c	/^float chu_values[98][4];    \/* Values to calculate straggling according to Chu's model;$/;"	v
coll_c	iran3d_all_140429.c	/^int coll_c;             \/* collide *\/$/;"	v
collision	iran3d_all_140429.c	/^int collision (int projZ, float projM, int is_ion, float *energy, double target_x,$/;"	f
column_R2	iran3d_all_140429.c	/^double column_R2[20];$/;"	v
column_height	iran3d_all_140429.c	/^double column_height[20];$/;"	v
column_intersect	iran3d_all_140429.c	/^int column_intersect (int seq, double TT[]) {$/;"	f
combine_files	iran3d_all_140429.c	/^int combine_files (int count, ...) {$/;"	f
compute_lists	iran3d_all_140429.c	/^void compute_lists (void) {$/;"	f
conv_create_separate_elements	iran3d_all_140429.c	/^int conv_create_separate_elements;$/;"	v
convert_material_to_element	iran3d_all_140429.c	/^int convert_material_to_element (char *output_file) {$/;"	f
copy_double_array	iran3d_all_140429.c	/^ double copy_double_array (double a[], double b[], int num_elements) {$/;"	f
copy_int_array	iran3d_all_140429.c	/^ int copy_int_array (int a[], int b[], int num_elements) {$/;"	f
cos_azim_angle	iran3d_all_140429.c	/^float cos_azim_angle[MAXAZILIST];$/;"	v
cos_scat	iran3d_all_140429.c	/^    float *cos_scat;             \/* cosines of scattering angles, for each energy and p *\/$/;"	m	struct:scattering_matrix	file:
count_existing_elements	iran3d_all_140429.c	/^int count_existing_elements (int *element_array) {$/;"	f
create_status_file	iran3d_all_140429.c	/^int    create_status_file;     \/* if this is 1, then iran3d output its status regularly to$/;"	v
cross_product	iran3d_all_140429.c	/^void cross_product (double a[], double b[], double c[]) {$/;"	f
cuboid_intersect	iran3d_all_140429.c	/^int cuboid_intersect (int seq, double TT[]) {$/;"	f
d2f	iran3d_all_140429.c	/^float d2f (double val) {$/;"	f
dc	iran3d_all_140429.c	/^double dc[20][3][2];$/;"	v
def_ion_enetry_pos	iran3d_all_140429.c	/^void def_ion_enetry_pos (double *x, double *y, double *z) {$/;"	f
density	iran3d_all_140429.c	/^    float density;              \/* total atomic density in at\/cm^3 *\/$/;"	m	struct:material	file:
density_NM	iran3d_all_140429.c	/^    float density_NM;           \/* total atomic density in at\/nm^3 *\/$/;"	m	struct:material	file:
detailed_sputtering	iran3d_all_140429.c	/^int detailed_sputtering;  \/* Needs to be set to 1, if you want to get better results regarding$/;"	v
di	iran3d_all_140429.c	/^int    di, dj, dk;  \/*  *\/$/;"	v
disp_c	iran3d_all_140429.c	/^int disp_c;             \/* dispalcement *\/$/;"	v
display_a_file	iran3d_all_140429.c	/^int display_a_file (char *file_name) {$/;"	f
display_interval	iran3d_all_140429.c	/^int    display_interval;        \/* display status every so many ions *\/$/;"	v
display_startup_message	iran3d_all_140429.c	/^int display_startup_message () {$/;"	f
dj	iran3d_all_140429.c	/^int    di, dj, dk;  \/*  *\/$/;"	v
dk	iran3d_all_140429.c	/^int    di, dj, dk;  \/*  *\/$/;"	v
do_depth_dist_statistics	iran3d_all_140429.c	/^void do_depth_dist_statistics (void) {$/;"	f
do_not_store_damage	iran3d_all_140429.c	/^int   do_not_store_damage;     \/* if 1, then far fewer data are stored to disc... saves memory *\/$/;"	v
dot_product	iran3d_all_140429.c	/^double dot_product (double a[], double b[]) {$/;"	f
electronic_stopping	iran3d_all_140429.c	/^float electronic_stopping (int ionZ, float ionM, float ionE, int material) {$/;"	f
electronic_straggling	iran3d_all_140429.c	/^float electronic_straggling (int ionZ, float ionM, float ionE, int material) {$/;"	f
element_count	iran3d_all_140429.c	/^    int   element_count;  \/* number of different elements contained in this material *\/$/;"	m	struct:material	file:
elemental_leaving_recoils	iran3d_all_140429.c	/^    struct transmitted_ion** elemental_leaving_recoils; \/* arrays storing recoils that are$/;"	m	struct:material	typeref:struct:material::transmitted_ion	file:
elements_M	iran3d_all_140429.c	/^    float elements_M[MAX_EL_PER_MAT];     \/* list of the element masses in this materials *\/$/;"	m	struct:material	file:
elements_Z	iran3d_all_140429.c	/^    int   elements_Z[MAX_EL_PER_MAT];     \/* list of the elements contained in this materials *\/$/;"	m	struct:material	file:
elements_conc	iran3d_all_140429.c	/^    float elements_conc[MAX_EL_PER_MAT];  \/* relative concentration of the elements *\/$/;"	m	struct:material	file:
elements_disp_energy	iran3d_all_140429.c	/^    float elements_disp_energy[MAX_EL_PER_MAT];  \/* displacement energy for each element in eV *\/$/;"	m	struct:material	file:
elements_latt_energy	iran3d_all_140429.c	/^    float elements_latt_energy[MAX_EL_PER_MAT];  \/* lattice energy for each element in eV *\/$/;"	m	struct:material	file:
elements_surf_energy	iran3d_all_140429.c	/^    float elements_surf_energy[MAX_EL_PER_MAT];  \/* surface binding energy for each element in eV *\/$/;"	m	struct:material	file:
ellipsoid_intersect	iran3d_all_140429.c	/^int ellipsoid_intersect (int seq, double TT[]) {$/;"	f
energy	iran3d_all_140429.c	/^    float  energy;            \/* exit energy *\/$/;"	m	struct:transmitted_ion	file:
enter_x	iran3d_all_140429.c	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_y	iran3d_all_140429.c	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_z	iran3d_all_140429.c	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
erf_list_pointer	iran3d_all_140429.c	/^unsigned int erf_list_pointer;  \/* points to next erf element to use *\/$/;"	v
escape_solid_c	iran3d_all_140429.c	/^int escape_solid_c;     \/* *\/$/;"	v
existing_elements	iran3d_all_140429.c	/^int existing_elements[MAX_ELEMENT_NO];  \/* This array holds a 1 for any element that might exist$/;"	v
fast_sqrt	iran3d_all_140429.c	/^float fast_sqrt (float val) {$/;"	f
file_format	iran3d_all_140429.c	/^int file_format;  \/\/ -> Config.in ?$/;"	v
fill_cos_sin_table	iran3d_all_140429.c	/^void fill_cos_sin_table (float *cos_table, float *sin_table, float mr) {$/;"	f
fill_double_zero	iran3d_all_140429.c	/^void fill_double_zero (double *array, int count) {$/;"	f
fill_fast_sqrt_table	iran3d_all_140429.c	/^void fill_fast_sqrt_table (void) {$/;"	f
fill_int_zero	iran3d_all_140429.c	/^void fill_int_zero (int *array, int count) {$/;"	f
find_x0	iran3d_all_140429.c	/^double find_x0 (double epsilon, double s) {$/;"	f
finds	iran3d_all_140429.c	/^double finds (double epsilon, double thetaCM) {$/;"	f
flag	iran3d_all_140429.c	/^    int   flag;             \/* used for triangulating *\/$/;"	m	struct:GRIDBOX	file:
flight_length_const	iran3d_all_140429.c	/^float flight_length_const;  \/* If constant flight length is selected, then this is it (in nm). *\/$/;"	v
flight_length_type	iran3d_all_140429.c	/^int flight_length_type;    \/* Flight lengths between collisions can be selected by three$/;"	v
freepath_csg	iran3d_all_140429.c	/^void freepath_csg (int projZ, int projM, float *energy, double flight_length, double *step,$/;"	f
freepath_fetm	iran3d_all_140429.c	/^void freepath_fetm (double *x, double *y, double *z, double *vx, double *vy, double *vz,$/;"	f
func_x0	iran3d_all_140429.c	/^double func_x0 (double x0, double epsilon, double s) {$/;"	f
gauss_random_list	iran3d_all_140429.c	/^float gauss_random_list[MAXRANLIST];  \/* Gauss distribution randomlist, ygli *\/$/;"	v
gen_shape_or_not	iran3d_all_140429.c	/^int gen_shape_or_not;  \/* 1 - generate fetm shape file for fetm geometry *\/$/;"	v
generate_fetm_tri_shape	iran3d_all_140429.c	/^int generate_fetm_tri_shape (void) {$/;"	f
geometry_type	iran3d_all_140429.c	/^int geometry_type;     \/* 0 - CSG, 1 - FETM *\/$/;"	v
get_cell_index	iran3d_all_140429.c	/^int get_cell_index (double x, double y, double z, int *cell_i) {$/;"	f
get_float_one_bit_smaller	iran3d_all_140429.c	/^void get_float_one_bit_smaller (float *flt_input, float *flt_output) {$/;"	f
get_leaving_direction	iran3d_all_140429.c	/^int get_leaving_direction (double vx, double vy, double vz) {$/;"	f
get_relative_XYZ	iran3d_all_140429.c	/^void get_relative_XYZ (int x, int y, int z, float *rx, float *ry, float *rz) {$/;"	f
get_target_XYZ	iran3d_all_140429.c	/^void get_target_XYZ (int index, int *x, int *y, int *z) {$/;"	f
get_target_index	iran3d_all_140429.c	/^int get_target_index (int x, int y, int z) {$/;"	f
handle_cmd_line_options	iran3d_all_140429.c	/^int handle_cmd_line_options (int argc, char *argv[]) {$/;"	f
headerRef	iran3d_all_140429.c	/^float headerRef[HEADERSIZE] = {MINE, DIME, MAXE, MINS, DIMS, MAXS, NSUM};$/;"	v
hydrogen_in_target	iran3d_all_140429.c	/^int hydrogen_in_target;                 \/* Hydrogen is always included in the existing_elements_list,$/;"	v
hyperboloid_AA	iran3d_all_140429.c	/^double hyperboloid_AA[20];$/;"	v
hyperboloid_BB	iran3d_all_140429.c	/^double hyperboloid_BB[20];$/;"	v
hyperboloid_RR	iran3d_all_140429.c	/^double hyperboloid_RR[20];$/;"	v
hyperboloid_distance	iran3d_all_140429.c	/^double hyperboloid_distance[20];$/;"	v
hyperboloid_height	iran3d_all_140429.c	/^double hyperboloid_height[20];$/;"	v
hyperboloid_intersect	iran3d_all_140429.c	/^int hyperboloid_intersect (int seq, double TT[]) {$/;"	f
hyperboloid_radius	iran3d_all_140429.c	/^double hyperboloid_radius[20];$/;"	v
ignoreline	iran3d_all_140429.c	/^void ignoreline (FILE *ifp) {$/;"	f
init_H	iran3d_all_140429.c	595;"	d	file:
init_configuration	iran3d_all_140429.c	/^int init_configuration (char *ConfigFileName) {$/;"	f
init_materials	iran3d_all_140429.c	/^int init_materials (char *file_name) {$/;"	f
init_target_structure	iran3d_all_140429.c	/^int init_target_structure (char *file_name) {$/;"	f
int_c	iran3d_all_140429.c	/^int int_c;              \/* interstitial *\/$/;"	v
interface_path	iran3d_all_140429.c	/^void interface_path (int s_count, double sect[][3], double *s, int projZ,$/;"	f
inv_screening_length	iran3d_all_140429.c	/^    float inv_screening_length;  \/* 1\/screening length in 1\/nm *\/$/;"	m	struct:scattering_matrix	file:
inv_sqrt	iran3d_all_140429.c	/^float inv_sqrt (float val) {$/;"	f
inv_sqrt_log_list	iran3d_all_140429.c	/^float inv_sqrt_log_list[MAXLOGLIST];   \/* 1\/sqrtloglist *\/$/;"	v
inv_sqrt_table	iran3d_all_140429.c	/^float inv_sqrt_table[1<<16];$/;"	v
inv_sqrt_table_exp	iran3d_all_140429.c	/^float inv_sqrt_table_exp[256];$/;"	v
inverse_erf_list	iran3d_all_140429.c	/^float inverse_erf_list[MAXERFLIST];  \/* list of evenly distributed but randomly ordered$/;"	v
ionZ_in_target	iran3d_all_140429.c	/^int ionZ_in_target;                     \/* The ion is always included in the existing_elements_list.$/;"	v
ion_M	iran3d_all_140429.c	/^float ion_M;                  \/* mass of the ion *\/$/;"	v
ion_Z	iran3d_all_140429.c	/^int   ion_Z;                  \/* proton number *\/$/;"	v
ion_c	iran3d_all_140429.c	/^int ion_c;              \/* ion *\/$/;"	v
ion_distribution	iran3d_all_140429.c	/^int   ion_distribution;      \/* 0 for random ion entry positions,$/;"	v
ion_initial_energy	iran3d_all_140429.c	/^float ion_initial_energy;     \/* impinging energy *\/$/;"	v
ion_paths_fp	iran3d_all_140429.c	/^FILE *ion_paths_fp;         \/* the file with the ion paths will be open all the time if the paths$/;"	v
ion_scattering_matrix	iran3d_all_140429.c	/^struct scattering_matrix ion_scattering_matrix[MAX_ELEMENT_NO];$/;"	v	typeref:struct:scattering_matrix
ion_surf_energy	iran3d_all_140429.c	/^    float ion_surf_energy;                \/* Surface binding energy of the ion in this material.$/;"	m	struct:material	file:
ion_vx	iran3d_all_140429.c	/^float ion_vx;                \/* vector of ion velocity, normalized to 1 *\/$/;"	v
ion_vy	iran3d_all_140429.c	/^float ion_vy;                \/* Note, that the ion is NOT described by its actual velocity vector, *\/$/;"	v
ion_vz	iran3d_all_140429.c	/^float ion_vz;                \/* but by the flying direction vector of length 1 and its energy. *\/$/;"	v
irradiate_target	iran3d_all_140429.c	/^int irradiate_target (void) {$/;"	f
is_full	iran3d_all_140429.c	/^int is_full[20];     \/* materials in shape elements *\/$/;"	v
juintersect	iran3d_all_140429.c	/^int juintersect (double *x, double *y, double *z, double vx, double vy, double vz) {$/;"	f
kfactor_m	iran3d_all_140429.c	/^    float kfactor_m;             \/* mass part of the kinematic factor.$/;"	m	struct:scattering_matrix	file:
layer_count_yz	iran3d_all_140429.c	/^int layer_count_yz;    \/* layer_count_xy = cell_count_x * cell_count_y,$/;"	v
layer_distance	iran3d_all_140429.c	/^    float layer_distance;       \/* layer distcance assuming simple cubic structure[nm] *\/$/;"	m	struct:material	file:
leaving_ions	iran3d_all_140429.c	/^int leaving_ions[8];        \/* number of ions, leaving target in each direction\/quadrants, ygli *\/$/;"	v
leaving_ions_c	iran3d_all_140429.c	/^int leaving_ions_c;     \/* *\/$/;"	v
leaving_recoils_c	iran3d_all_140429.c	/^int leaving_recoils_c;  \/* *\/$/;"	v
leaving_recoils_pointer	iran3d_all_140429.c	/^    int *leaving_recoils_pointer;      \/* array of pointers which for each element of this material$/;"	m	struct:material	file:
line_flag	iran3d_all_140429.c	/^int    line_flag;$/;"	v
list_of_materials	iran3d_all_140429.c	/^struct material list_of_materials[MAX_NO_MATERIALS];$/;"	v	typeref:struct:material
load_Chu_straggling_values	iran3d_all_140429.c	/^int load_Chu_straggling_values () {$/;"	f
load_inverse_Erf	iran3d_all_140429.c	/^int load_inverse_Erf () {$/;"	f
load_matrix	iran3d_all_140429.c	/^int load_matrix (char file_name[]) {$/;"	f
log_list	iran3d_all_140429.c	/^float log_list[MAXLOGLIST];       \/* ygli *\/$/;"	v
main	iran3d_all_140429.c	/^int main (int argc, char *argv[]) {$/;"	f
make_double_array	iran3d_all_140429.c	/^int make_double_array (char *values, int count, double *d_array) {$/;"	f
make_float_array	iran3d_all_140429.c	/^int make_float_array (char *values, int count, float *f_array) {$/;"	f
make_int_array	iran3d_all_140429.c	/^int make_int_array (char *values, int count, int *i_array) {$/;"	f
make_line	iran3d_all_140429.c	/^void make_line (double x, double y, double z, double vx,$/;"	f
make_line_tri	iran3d_all_140429.c	/^void make_line_tri (int flag_or_not, double sin_theta, double cos_theta,$/;"	f
mass_ratio	iran3d_all_140429.c	/^    float mass_ratio;            \/* ... *\/$/;"	m	struct:scattering_matrix	file:
mat_mul	iran3d_all_140429.c	/^void mat_mul (double a[], double b[], int m, int n, int k, double c[]) {$/;"	f
mater_type	iran3d_all_140429.c	/^    int   mater_type[800];  \/* material type inside this triangle, 100 -> 800 *\/$/;"	m	struct:GRIDBOX	file:
material	iran3d_all_140429.c	/^int material[20];$/;"	v
material	iran3d_all_140429.c	/^struct material                 \/* all properties of a material *\/$/;"	s	file:
matrix	iran3d_all_140429.c	/^float matrix[DIME*DIMS];$/;"	v
matrix_i	iran3d_all_140429.c	/^float matrix_i (unsigned long i) {$/;"	f
max_annular_coll_volumes	iran3d_all_140429.c	/^int max_annular_coll_volumes;  \/* According to W.Eckstein "Computer Simulation if Ion-Solid$/;"	v
max_loc_abs	iran3d_all_140429.c	/^int max_loc_abs (double a[], int n) {$/;"	f
max_no_ions	iran3d_all_140429.c	/^int   max_no_ions;            \/* maximum number of ions *\/$/;"	v
mean_A	iran3d_all_140429.c	/^    float mean_A;      \/* average A (screening length), weighted by fraction, *\/$/;"	m	struct:material	file:
mean_F	iran3d_all_140429.c	/^    float mean_F;      \/* average F (reduced energy conversion factor), weighted by fraction *\/$/;"	m	struct:material	file:
mean_M	iran3d_all_140429.c	/^    float mean_M;      \/* average M, weighted by fraction *\/$/;"	m	struct:material	file:
mean_Z	iran3d_all_140429.c	/^    float mean_Z;      \/* average Z, weighted by fraction *\/$/;"	m	struct:material	file:
mean_impact_par	iran3d_all_140429.c	/^    float mean_impact_par;         \/* not actually the mean impact paramater but rather$/;"	m	struct:material	file:
mean_min_red_transfer	iran3d_all_140429.c	/^    float mean_min_red_transfer;  \/* average minimun energy transfer in reduced units *\/$/;"	m	struct:material	file:
mem_usage	iran3d_all_140429.c	/^unsigned long int mem_usage;   \/* if mem_usage active, then sum it up here (in bytes) *\/$/;"	v
mem_usage_details	iran3d_all_140429.c	/^int mem_usage_details;         \/* if 1, print more details for memory usage *\/$/;"	v
mem_usage_only	iran3d_all_140429.c	/^int mem_usage_only;            \/* if 1, then do not simulate anything, just estimate memory usage *\/$/;"	v
min_energy	iran3d_all_140429.c	/^float min_energy;            \/* minimum energy below which all projectiles are stopped *\/$/;"	v
miss_c	iran3d_all_140429.c	/^int miss_c;             \/* missed collision *\/$/;"	v
most_abundant_isotope	iran3d_all_140429.c	/^float most_abundant_isotope[NUMBERELEMENTS];$/;"	v
most_abundant_isotope	iran3d_all_140429.c	/^float most_abundant_isotope[] = { 92,$/;"	v
my_shape	iran3d_all_140429.c	/^int my_shape[20];    \/* indexes of shape elements *\/$/;"	v
name	iran3d_all_140429.c	/^    char  name[50];             \/* a name can be defined *\/$/;"	m	struct:material	file:
normalize_output	iran3d_all_140429.c	/^int normalize_output;          \/* if 1, the output of the program will be normalized to$/;"	v
num_of_data	iran3d_all_140429.c	/^int num_of_data[20];$/;"	v
num_of_material	iran3d_all_140429.c	/^int num_of_material;$/;"	v
num_triangles	iran3d_all_140429.c	/^    int   num_triangles;    \/* number of triangles in this box *\/$/;"	m	struct:GRIDBOX	file:
number_of_all_target_elements	iran3d_all_140429.c	/^int    number_of_all_target_elements;  \/* without ion. *\/$/;"	v
number_of_materials	iran3d_all_140429.c	/^int    number_of_materials;            \/* points to first free index in the ListOfMaterials *\/$/;"	v
open_file_continuous	iran3d_all_140429.c	/^FILE *open_file_continuous (char *base_name, char *extension) {$/;"	f
orientation	iran3d_all_140429.c	/^double orientation[20][3][3];$/;"	v
output_format	iran3d_all_140429.c	/^int output_format;             \/* if 1, iradiana output format; if 2, cfg output_format *\/$/;"	v
override_energy	iran3d_all_140429.c	/^float  override_energy;         \/* for command-line argument override of ion energy *\/$/;"	v
override_max_ions	iran3d_all_140429.c	/^int    override_max_ions;       \/* for command-line argument override of maximum number of ions *\/$/;"	v
paraboloid_RR	iran3d_all_140429.c	/^double paraboloid_RR[20];$/;"	v
paraboloid_RRH	iran3d_all_140429.c	/^double paraboloid_RRH[20];$/;"	v
paraboloid_height	iran3d_all_140429.c	/^double paraboloid_height[20];$/;"	v
paraboloid_intersect	iran3d_all_140429.c	/^int paraboloid_intersect (int seq, double TT[]) {$/;"	f
paraboloid_radius	iran3d_all_140429.c	/^double paraboloid_radius[20];$/;"	v
phi_LJ	iran3d_all_140429.c	/^double phi_LJ (double x) {$/;"	f
phi_none	iran3d_all_140429.c	/^double phi_none (double x) {$/;"	f
phi_univ	iran3d_all_140429.c	/^double phi_univ (double x) {$/;"	f
plane2_intersect	iran3d_all_140429.c	/^int plane2_intersect (double N[], double LVO, double D[], double T2[]) {$/;"	f
point	iran3d_all_140429.c	/^double point[20][4][3];$/;"	v
polygon_Cnt	iran3d_all_140429.c	/^int polygon_Cnt[20];$/;"	v
polygon_intersect	iran3d_all_140429.c	/^int polygon_intersect (double PTmp[][3], int Cnt, double P0[]) {$/;"	f
polygon_vertex	iran3d_all_140429.c	/^double polygon_vertex[20][20][20][3];$/;"	v
polyhedron_intersect	iran3d_all_140429.c	/^int polyhedron_intersect (int seq, double TT[]) {$/;"	f
position_in_cell	iran3d_all_140429.c	/^void position_in_cell (double x, double y, double z, double *rx, double *ry, double *rz) {$/;"	f
prepare_scattering_matrix	iran3d_all_140429.c	/^int prepare_scattering_matrix (struct scattering_matrix *scat_matrix, float proj_M,$/;"	f
prepare_stopping_tables	iran3d_all_140429.c	/^int prepare_stopping_tables (void) {$/;"	f
prepare_straggling_tables	iran3d_all_140429.c	/^int prepare_straggling_tables (int model) {$/;"	f
print_help_text	iran3d_all_140429.c	/^int print_help_text (void) {$/;"	f
print_level	iran3d_all_140429.c	/^int print_level;               \/* determines how much stuff is printed to the console$/;"	v
projectile_transport	iran3d_all_140429.c	/^int projectile_transport (int projZ, float projM, float projE, double proj_x,$/;"	f
ran_list	iran3d_all_140429.c	/^unsigned int ran_list;          \/* points to next entry in the random list *\/$/;"	v
ran_log_list	iran3d_all_140429.c	/^unsigned int ran_log_list;      \/* points to next entry in the random sqrt logarithmic list *\/$/;"	v
random_list	iran3d_all_140429.c	/^float random_list[MAXRANLIST];$/;"	v
randomize_list	iran3d_all_140429.c	/^void randomize_list (float *list, unsigned int max_list) {$/;"	f
randomx	iran3d_all_140429.c	/^double randomx () {$/;"	f
read_config_file_data	iran3d_all_140429.c	/^int read_config_file_data (char *par_name, char *par_value) {$/;"	f
read_config_file_data_block	iran3d_all_140429.c	/^int read_config_file_data_block (char *block_name) {$/;"	f
read_csg_shape	iran3d_all_140429.c	/^int read_csg_shape (char *file_name) {$/;"	f
read_fetm_shape	iran3d_all_140429.c	/^int read_fetm_shape (char *file_name) {$/;"	f
read_file_opengl	iran3d_all_140429.c	/^int read_file_opengl (int n, int num_of_data) {$/;"	f
read_file_ply2	iran3d_all_140429.c	/^int read_file_ply2 (int n) {$/;"	f
read_float_block	iran3d_all_140429.c	/^int read_float_block (char *file_name, int offset, int count, float *array) {$/;"	f
read_float_file_into_array	iran3d_all_140429.c	/^int read_float_file_into_array (char *file_name, float *target_array, int count,$/;"	f
read_init_file	iran3d_all_140429.c	/^int read_init_file (int (*read_data_block) (char *block_name),$/;"	f
read_materials_data	iran3d_all_140429.c	/^int read_materials_data (char *par_name, char *par_value) {$/;"	f
read_materials_data_block	iran3d_all_140429.c	/^int read_materials_data_block (char *material_name) {$/;"	f
read_rotation	iran3d_all_140429.c	/^int read_rotation (int i, double *ax, double *ay, double *az) {$/;"	f
read_scaling	iran3d_all_140429.c	/^int read_scaling (int i) {$/;"	f
read_shearing	iran3d_all_140429.c	/^int read_shearing (int i) {$/;"	f
read_target_structure_data	iran3d_all_140429.c	/^int read_target_structure_data (char *par_name, char *par_value) {$/;"	f
read_target_structure_data_block	iran3d_all_140429.c	/^int read_target_structure_data_block (char *block_name) {$/;"	f
read_translation	iran3d_all_140429.c	/^int read_translation (int i) {$/;"	f
recoil_cascades_fp	iran3d_all_140429.c	/^FILE *recoil_cascades_fp;   \/* the file with the recoil cascades will be open all the time if the$/;"	v
red_E_conv	iran3d_all_140429.c	/^    float red_E_conv;            \/* reduced energy conversion factor. This is called FI in TRIM *\/$/;"	m	struct:scattering_matrix	file:
refract_projectile2	iran3d_all_140429.c	/^int refract_projectile2 (double *vx, double *vy, double *vz, double nx, double ny,$/;"	f
refraction	iran3d_all_140429.c	/^void refraction (double NT[], double *vx, double *vy, double *vz, int *S_flag,$/;"	f
repl_c	iran3d_all_140429.c	/^int repl_c;             \/* replacement *\/$/;"	v
rev_atomic_distance	iran3d_all_140429.c	/^    float rev_atomic_distance;  \/* 1.0\/AtomicDistance [nm^-1], ygli *\/$/;"	m	struct:material	file:
rotate	iran3d_all_140429.c	/^void rotate (double *l, double *m, double *n, unsigned int *iazim_angle,$/;"	f
rx	iran3d_all_140429.c	/^double rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
rxyz	iran3d_all_140429.c	/^double rxyz[20][3][3];$/;"	v
ry	iran3d_all_140429.c	/^double rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
rz	iran3d_all_140429.c	/^double rx, ry, rz;  \/* relative x, y, z *\/$/;"	v
s_count	iran3d_all_140429.c	/^int s_count;         \/* number of shape elements *\/$/;"	v
scaling	iran3d_all_140429.c	/^double scaling[20][3];$/;"	v
scaling_x	iran3d_all_140429.c	/^double scaling_x, scaling_y, scaling_z;$/;"	v
scaling_y	iran3d_all_140429.c	/^double scaling_x, scaling_y, scaling_z;$/;"	v
scaling_z	iran3d_all_140429.c	/^double scaling_x, scaling_y, scaling_z;$/;"	v
scattering_calculation	iran3d_all_140429.c	/^int scattering_calculation;     \/* 0: corteo database, 1: MAGIC  *\/$/;"	v
scattering_matrices	iran3d_all_140429.c	/^struct scattering_matrix scattering_matrices[MAX_ELEMENT_NO][MAX_ELEMENT_NO];$/;"	v	typeref:struct:scattering_matrix
scattering_matrix	iran3d_all_140429.c	/^struct scattering_matrix  \/* This structure holds information for a scattering events of two$/;"	s	file:
screening_length	iran3d_all_140429.c	/^    float screening_length;      \/* screening length from ZBL85,p45, eq.2-60, but in [nm] *\/$/;"	m	struct:scattering_matrix	file:
screening_type	iran3d_all_140429.c	674;"	d	file:
sect_sort	iran3d_all_140429.c	/^void sect_sort (int *n, double sect[]) {$/;"	f
seed1	iran3d_all_140429.c	/^int seed1, seed2;$/;"	v
seed2	iran3d_all_140429.c	/^int seed1, seed2;$/;"	v
set_matrix	iran3d_all_140429.c	/^void set_matrix (unsigned long i, float val) {$/;"	f
shearing	iran3d_all_140429.c	/^double shearing[20][3][3];$/;"	v
shift	iran3d_all_140429.c	/^double shift[20][3];$/;"	v
signd	iran3d_all_140429.c	/^double signd (double d) {$/;"	f
signf	iran3d_all_140429.c	/^float signf (float f) {$/;"	f
simulation_type	iran3d_all_140429.c	/^int simulation_type;  \/* How to do the simulation.$/;"	v
sin_azim_angle	iran3d_all_140429.c	/^float sin_azim_angle[MAXAZILIST];   \/* list cos and sin components of angles... *\/$/;"	v
sin_scat	iran3d_all_140429.c	/^    float *sin_scat;             \/* sines of scattering angles, for each energy and p *\/$/;"	m	struct:scattering_matrix	file:
single_input_file	iran3d_all_140429.c	/^int single_input_file;  \/* if 0, then multiple files (normal).$/;"	v
single_ion_sputter_counter	iran3d_all_140429.c	/^int single_ion_sputter_counter;$/;"	v
single_ion_sputter_yields	iran3d_all_140429.c	/^int single_ion_sputter_yields;  \/* if 1, iradina will store sputter yields for single ions$/;"	v
sphere_C	iran3d_all_140429.c	/^double sphere_C[20][3];$/;"	v
sphere_R2	iran3d_all_140429.c	/^double sphere_R2[20];$/;"	v
sphere_intersect	iran3d_all_140429.c	/^int sphere_intersect (int seq, double TT[]) {$/;"	f
split_single_input_file	iran3d_all_140429.c	/^int split_single_input_file (char *file_name) {$/;"	f
sputter_c	iran3d_all_140429.c	/^int sputter_c;          \/* sputtering *\/$/;"	v
sputter_counter	iran3d_all_140429.c	/^    int   sputter_counter[MAX_EL_PER_MAT*8];  \/* count sputtered atoms leaving the sample in each$/;"	m	struct:material	file:
sputter_yield_histogram	iran3d_all_140429.c	/^int *sputter_yield_histogram;   \/* array that stores single ion sputter yield histogram *\/$/;"	v
sqrt_mass_ratio	iran3d_all_140429.c	/^    float sqrt_mass_ratio;       \/* we will need this occasionally *\/$/;"	m	struct:scattering_matrix	file:
sqrt_random_list	iran3d_all_140429.c	/^float sqrt_random_list[MAXRANLIST];   \/* sqrt of randomlist *\/$/;"	v
sqrt_rec_fl_density	iran3d_all_140429.c	/^    float sqrt_rec_fl_density;     \/* 1\/sqrt(pi*flight_length_constant*density) needed for$/;"	m	struct:material	file:
sqrt_table	iran3d_all_140429.c	/^float sqrt_table[1<<16];$/;"	v
sqrt_table_exp	iran3d_all_140429.c	/^float sqrt_table_exp[256];$/;"	v
sqrtdf	iran3d_all_140429.c	/^float sqrtdf (double val) {$/;"	f
start_id_string	iran3d_all_140429.c	/^char *start_id_string;         \/* string that helps other programs to identify iran3d output *\/$/;"	v
status_update_interval	iran3d_all_140429.c	/^int    status_update_interval;  \/* After so many ions, the status is written to the status file$/;"	v
stopping_ZE	iran3d_all_140429.c	/^    float **stopping_ZE;                \/* points to an array of 92 elements (the Zs) which contain$/;"	m	struct:material	file:
storage_interval	iran3d_all_140429.c	/^int    storage_interval;        \/* dump the target arrays into the files every such number of ions *\/$/;"	v
store_depth_dist_array	iran3d_all_140429.c	/^int store_depth_dist_array (char *file_name) {$/;"	f
store_energy_deposit	iran3d_all_140429.c	/^int store_energy_deposit;  \/* if 1, array with deposited energy are created and stored;$/;"	v
store_exiting_limit	iran3d_all_140429.c	/^int store_exiting_limit;     \/* maximum number of exiting recoils to be stored *\/$/;"	v
store_exiting_recoils	iran3d_all_140429.c	/^int store_exiting_recoils;   \/* 1 if all exiting recoils should be stored *\/$/;"	v
store_ion_paths	iran3d_all_140429.c	/^int store_ion_paths;  \/* 1 if the exact paths should be stored (interesting for debugging stuff *\/$/;"	v
store_path_limit	iran3d_all_140429.c	/^int store_path_limit;        \/* only for so many ions, the exact paths and recoil cascades are stored *\/$/;"	v
store_recoil_cascades	iran3d_all_140429.c	/^int store_recoil_cascades;  \/* 1 if the exact recoils cascades should be stored$/;"	v
store_results_cfg	iran3d_all_140429.c	/^int store_results_cfg (char *base_name) {$/;"	f
store_results_iradina	iran3d_all_140429.c	/^int store_results_iradina (char *base_name) {$/;"	f
store_transmission_array	iran3d_all_140429.c	/^int store_transmission_array (char *file_name, struct transmitted_ion *trans_array,$/;"	f
store_transmitted_ions	iran3d_all_140429.c	/^int store_transmitted_ions;  \/* 1 if true *\/$/;"	v
straggling_ZE	iran3d_all_140429.c	/^    float **straggling_ZE;              \/* we need the same for energy loss straggling *\/$/;"	m	struct:material	file:
straggling_model	iran3d_all_140429.c	/^int straggling_model;       \/* how to calc straggling *\/$/;"	v
sub_surf_z	iran3d_all_140429.c	/^float sub_surf_z;      \/* z coordinate of the half-infinite substrate surface in nm *\/$/;"	v
sum_array	iran3d_all_140429.c	/^ double sum_array (double a[], int num_elements) {$/;"	f
sum_up_material_arrays	iran3d_all_140429.c	/^void sum_up_material_arrays (void) {$/;"	f
taper_TgT2	iran3d_all_140429.c	/^double taper_TgT2[20];$/;"	v
taper_height	iran3d_all_140429.c	/^double taper_height[20];$/;"	v
taper_intersect	iran3d_all_140429.c	/^int taper_intersect (int seq, double TT[]) {$/;"	f
target_composition	iran3d_all_140429.c	/^int   *target_composition;          \/* material of each cell *\/$/;"	v
target_composition_file_type	iran3d_all_140429.c	/^int target_composition_file_type;   \/* The file which hold the info of what material is in$/;"	v
target_depth_elemental_disp	iran3d_all_140429.c	/^    int **target_depth_elemental_disp;$/;"	m	struct:material	file:
target_depth_elemental_vacancies	iran3d_all_140429.c	/^    int **target_depth_elemental_vacancies;$/;"	m	struct:material	file:
target_depth_energy_electrons	iran3d_all_140429.c	/^double *target_depth_energy_electrons;$/;"	v
target_depth_energy_phonons	iran3d_all_140429.c	/^double *target_depth_energy_phonons;$/;"	v
target_depth_implanted_ions	iran3d_all_140429.c	/^int   *target_depth_implanted_ions;$/;"	v
target_depth_implanted_recoils_int	iran3d_all_140429.c	/^    int **target_depth_implanted_recoils_int;$/;"	m	struct:material	file:
target_depth_implanted_recoils_repl	iran3d_all_140429.c	/^    int **target_depth_implanted_recoils_repl;$/;"	m	struct:material	file:
target_depth_replacing_ions	iran3d_all_140429.c	/^int   *target_depth_replacing_ions;$/;"	v
target_depth_total_displacements	iran3d_all_140429.c	/^int   *target_depth_total_displacements;$/;"	v
target_depth_total_interstitials	iran3d_all_140429.c	/^int   *target_depth_total_interstitials;$/;"	v
target_depth_total_replacements	iran3d_all_140429.c	/^int   *target_depth_total_replacements;$/;"	v
target_depth_total_vacancies	iran3d_all_140429.c	/^int   *target_depth_total_vacancies;$/;"	v
target_elemental_disp	iran3d_all_140429.c	/^    int **target_elemental_disp;         \/* displacements of this element that took place *\/$/;"	m	struct:material	file:
target_elemental_vacancies	iran3d_all_140429.c	/^    int **target_elemental_vacancies;    \/* vacancies of this element left behind *\/$/;"	m	struct:material	file:
target_energy_electrons	iran3d_all_140429.c	/^double *target_energy_electrons;    \/* all energy deposited by electronic stopping.$/;"	v
target_energy_phonons	iran3d_all_140429.c	/^double *target_energy_phonons;      \/* all energy deposited into the phononic system *\/$/;"	v
target_implanted_ions	iran3d_all_140429.c	/^int   *target_implanted_ions;       \/* implanted ions per cell (interstitials+replacements) *\/$/;"	v
target_implanted_recoils_int	iran3d_all_140429.c	/^    int **target_implanted_recoils_int;   \/* the implanted recoils stopped as interstitials *\/$/;"	m	struct:material	file:
target_implanted_recoils_repl	iran3d_all_140429.c	/^    int **target_implanted_recoils_repl;  \/* the implanted recoils stopped as replacement atoms *\/$/;"	m	struct:material	file:
target_max_x	iran3d_all_140429.c	/^float target_max_x;    \/* maximum allowed position in x-direction in nm *\/$/;"	v
target_max_y	iran3d_all_140429.c	/^float target_max_y;    \/* these positions are the largest possible values, *\/$/;"	v
target_max_z	iran3d_all_140429.c	/^float target_max_z;    \/* which are smaller target_size_x etc. *\/$/;"	v
target_replacing_ions	iran3d_all_140429.c	/^int   *target_replacing_ions;       \/* implanted ions that replaced identical target atoms *\/$/;"	v
target_size_x	iran3d_all_140429.c	/^float target_size_x;   \/* size of target in x-direction in nm *\/$/;"	v
target_size_y	iran3d_all_140429.c	/^float target_size_y;   \/* they are calculated *\/$/;"	v
target_size_z	iran3d_all_140429.c	/^float target_size_z;$/;"	v
target_sputtered_atoms	iran3d_all_140429.c	/^    int **target_sputtered_atoms;        \/* number of atoms sputtered from this cell *\/$/;"	m	struct:material	file:
target_total_displacements	iran3d_all_140429.c	/^int   *target_total_displacements;  \/* displacements per cell (of all types) *\/ \/* Disp = Vac + Repl *\/$/;"	v
target_total_interstitials	iran3d_all_140429.c	/^int   *target_total_interstitials;  \/* sum of interstitials per cell (of all recoil$/;"	v
target_total_replacements	iran3d_all_140429.c	/^int   *target_total_replacements;   \/* replacements per cell (of all types) *\/$/;"	v
target_total_sputtered	iran3d_all_140429.c	/^int  *target_total_sputtered;       \/* sum of sputtered atoms from each cell *\/$/;"	v
target_total_vacancies	iran3d_all_140429.c	/^int   *target_total_vacancies;      \/* vacancies per cell (of all types) *\/$/;"	v
tetrahedron_intersect	iran3d_all_140429.c	/^int tetrahedron_intersect (int seq, double TT[]) {$/;"	f
total_sputter_counter	iran3d_all_140429.c	/^int total_sputter_counter[8];       \/* number of target atoms leaving the sample in each of the$/;"	v
trans_TT	iran3d_all_140429.c	/^void trans_TT (int seq, double TT[]) {$/;"	f
transmission	iran3d_all_140429.c	/^void transmission (double uz, int idied, float energy, float U0) {$/;"	f
transmission_pointer	iran3d_all_140429.c	/^int transmission_pointer;    \/* point to next free index in array *\/$/;"	v
transmit_list	iran3d_all_140429.c	/^struct transmitted_ion *transmit_list;  \/* list of transmitted ions *\/$/;"	v	typeref:struct:transmitted_ion
transmitted_ion	iran3d_all_140429.c	/^struct transmitted_ion       \/* describes an ion that has been transmitted (left the target) *\/$/;"	s	file:
transport_type	iran3d_all_140429.c	/^int transport_type;             \/* 0: accurate, 1: Fast (like corteo) *\/$/;"	v
triangle	iran3d_all_140429.c	/^double **triangle;$/;"	v
triangle_intersect_csg	iran3d_all_140429.c	/^int triangle_intersect_csg (double P[][3], double *temp, int *flag) {$/;"	f
triangle_intersect_fetm	iran3d_all_140429.c	/^int triangle_intersect_fetm (double trix1, double triy1, double triz1, double trix2,$/;"	f
unit_conversion_factor	iran3d_all_140429.c	/^double unit_conversion_factor; \/* This converts output to unit of (1\/cm^3)per(1\/cm^2) *\/$/;"	v
update_xyz	iran3d_all_140429.c	/^void update_xyz (double *x, double *y, double *z, double vx, double vy, double vz, double s) {$/;"	f
use_density_mult	iran3d_all_140429.c	/^int   use_density_mult;             \/* 0 if multiplicators not used, 1 if used *\/$/;"	v
vac_c	iran3d_all_140429.c	/^int vac_c;              \/* vacancy *\/$/;"	v
vertex_Cnt	iran3d_all_140429.c	/^int vertex_Cnt[20][20];$/;"	v
vx	iran3d_all_140429.c	/^    double vx;                \/* exit velocity unit vector *\/$/;"	m	struct:transmitted_ion	file:
vy	iran3d_all_140429.c	/^    double vy;$/;"	m	struct:transmitted_ion	file:
vz	iran3d_all_140429.c	/^    double vz;$/;"	m	struct:transmitted_ion	file:
wait_before_end	iran3d_all_140429.c	/^int wait_before_end;           \/* if 1, the program only quits after pressing return key *\/$/;"	v
write_double_array_to_cfg_file	iran3d_all_140429.c	/^int write_double_array_to_cfg_file (char *file_name, double *source_array1,$/;"	f
write_double_array_to_file	iran3d_all_140429.c	/^int write_double_array_to_file (char *file_name, double *source_array, int count, int file_type) {$/;"	f
write_float_array_to_file	iran3d_all_140429.c	/^int write_float_array_to_file (char *file_name, float *source_array, int count, int file_type) {$/;"	f
write_int_array_to_cfg_file	iran3d_all_140429.c	/^int write_int_array_to_cfg_file (char *file_name, int mat_i, int *source_array_total,$/;"	f
write_int_array_to_file	iran3d_all_140429.c	/^int write_int_array_to_file (char *file_name, int *source_array, int count, int file_type) {$/;"	f
write_rotation	iran3d_all_140429.c	/^int write_rotation (int i, double ax, double ay, double az) {$/;"	f
write_shear_scale	iran3d_all_140429.c	/^int write_shear_scale (int i) {$/;"	f
write_status_file	iran3d_all_140429.c	/^int write_status_file (char *status_text, int ion_number) {$/;"	f
write_string_to_file	iran3d_all_140429.c	/^int write_string_to_file (char *file_name, char *str) {$/;"	f
write_translation	iran3d_all_140429.c	/^int write_translation (int i) {$/;"	f
x	iran3d_all_140429.c	/^    double x;                 \/* exit position x *\/$/;"	m	struct:transmitted_ion	file:
xyz_flag	iran3d_all_140429.c	/^double xyz_flag;$/;"	v
y	iran3d_all_140429.c	/^    double y;                 \/* y *\/$/;"	m	struct:transmitted_ion	file:
z	iran3d_all_140429.c	/^    double z;                 \/* z *\/$/;"	m	struct:transmitted_ion	file:
z0_max	iran3d_all_140429.c	/^float z0_max;$/;"	v
MAGIC_A	magic.c	/^double MAGIC_A (double B, double epsilon) {$/;"	f
ZBL_and_deri	magic.c	/^double ZBL_and_deri (double R, double *Vprime) {$/;"	f
MAGIC_H	magic.h	15;"	d
CC	makefile	/^CC = mpicc$/;"	m
CFLAGS	makefile	/^CFLAGS = -O1 -Wall -m32  # ygli, 32bit, -arch i386$/;"	m
LDFLAGS	makefile	/^LDFLAGS = -lm -m32  #-v$/;"	m
convert_material_to_element	material.c	/^int convert_material_to_element (char *output_file) {$/;"	f
count_existing_elements	material.c	/^int count_existing_elements (int *element_array) {$/;"	f
init_materials	material.c	/^int init_materials (char *file_name) {$/;"	f
prepare_stopping_tables	material.c	/^int prepare_stopping_tables (void) {$/;"	f
prepare_straggling_tables	material.c	/^int prepare_straggling_tables (int model) {$/;"	f
read_materials_data	material.c	/^int read_materials_data (char *par_name, char *par_value) {$/;"	f
read_materials_data_block	material.c	/^int read_materials_data_block (char *material_name) {$/;"	f
MATERIAL_H	material.h	15;"	d
MAX_ELEMENT_NO	material.h	45;"	d
MAX_EL_PER_MAT	material.h	43;"	d
MAX_NO_MATERIALS	material.h	44;"	d
atomic_distance	material.h	/^    float atomic_distance;      \/* average inter-atomic distance [nm] *\/$/;"	m	struct:material
cell_count	material.h	/^    int   cell_count;  \/* number of cells that consist of this material *\/$/;"	m	struct:material
density	material.h	/^    float density;              \/* total atomic density in at\/cm^3 *\/$/;"	m	struct:material
density_NM	material.h	/^    float density_NM;           \/* total atomic density in at\/nm^3 *\/$/;"	m	struct:material
element_count	material.h	/^    int   element_count;  \/* number of different elements contained in this material *\/$/;"	m	struct:material
elemental_leaving_recoils	material.h	/^    struct transmitted_ion** elemental_leaving_recoils; \/* arrays storing recoils that are$/;"	m	struct:material	typeref:struct:material::transmitted_ion
elements_M	material.h	/^    float elements_M[MAX_EL_PER_MAT];     \/* list of the element masses in this materials *\/$/;"	m	struct:material
elements_Z	material.h	/^    int   elements_Z[MAX_EL_PER_MAT];     \/* list of the elements contained in this materials *\/$/;"	m	struct:material
elements_conc	material.h	/^    float elements_conc[MAX_EL_PER_MAT];  \/* relative concentration of the elements *\/$/;"	m	struct:material
elements_disp_energy	material.h	/^    float elements_disp_energy[MAX_EL_PER_MAT];  \/* displacement energy for each element in eV *\/$/;"	m	struct:material
elements_latt_energy	material.h	/^    float elements_latt_energy[MAX_EL_PER_MAT];  \/* lattice energy for each element in eV *\/$/;"	m	struct:material
elements_surf_energy	material.h	/^    float elements_surf_energy[MAX_EL_PER_MAT];  \/* surface binding energy for each element in eV *\/$/;"	m	struct:material
existing_elements	material.h	/^int existing_elements[MAX_ELEMENT_NO];  \/* This array holds a 1 for any element that might exist$/;"	v
hydrogen_in_target	material.h	/^int hydrogen_in_target;                 \/* Hydrogen is always included in the existing_elements_list,$/;"	v
ionZ_in_target	material.h	/^int ionZ_in_target;                     \/* The ion is always included in the existing_elements_list.$/;"	v
ion_surf_energy	material.h	/^    float ion_surf_energy;                \/* Surface binding energy of the ion in this material.$/;"	m	struct:material
layer_distance	material.h	/^    float layer_distance;       \/* layer distcance assuming simple cubic structure[nm] *\/$/;"	m	struct:material
leaving_recoils_pointer	material.h	/^    int *leaving_recoils_pointer;      \/* array of pointers which for each element of this material$/;"	m	struct:material
list_of_materials	material.h	/^struct material list_of_materials[MAX_NO_MATERIALS];$/;"	v	typeref:struct:material
material	material.h	/^struct material                 \/* all properties of a material *\/$/;"	s
mean_A	material.h	/^    float mean_A;      \/* average A (screening length), weighted by fraction, *\/$/;"	m	struct:material
mean_F	material.h	/^    float mean_F;      \/* average F (reduced energy conversion factor), weighted by fraction *\/$/;"	m	struct:material
mean_M	material.h	/^    float mean_M;      \/* average M, weighted by fraction *\/$/;"	m	struct:material
mean_Z	material.h	/^    float mean_Z;      \/* average Z, weighted by fraction *\/$/;"	m	struct:material
mean_impact_par	material.h	/^    float mean_impact_par;         \/* not actually the mean impact paramater but rather$/;"	m	struct:material
mean_min_red_transfer	material.h	/^    float mean_min_red_transfer;  \/* average minimun energy transfer in reduced units *\/$/;"	m	struct:material
name	material.h	/^    char  name[50];             \/* a name can be defined *\/$/;"	m	struct:material
number_of_all_target_elements	material.h	/^int    number_of_all_target_elements;  \/* without ion. *\/$/;"	v
number_of_materials	material.h	/^int    number_of_materials;            \/* points to first free index in the ListOfMaterials *\/$/;"	v
rev_atomic_distance	material.h	/^    float rev_atomic_distance;  \/* 1.0\/AtomicDistance [nm^-1], ygli *\/$/;"	m	struct:material
sputter_counter	material.h	/^    int   sputter_counter[MAX_EL_PER_MAT*8];  \/* count sputtered atoms leaving the sample in each$/;"	m	struct:material
sqrt_rec_fl_density	material.h	/^    float sqrt_rec_fl_density;     \/* 1\/sqrt(pi*flight_length_constant*density) needed for$/;"	m	struct:material
stopping_ZE	material.h	/^    float **stopping_ZE;                \/* points to an array of 92 elements (the Zs) which contain$/;"	m	struct:material
straggling_ZE	material.h	/^    float **straggling_ZE;              \/* we need the same for energy loss straggling *\/$/;"	m	struct:material
target_depth_elemental_disp	material.h	/^    int **target_depth_elemental_disp;$/;"	m	struct:material
target_depth_elemental_vacancies	material.h	/^    int **target_depth_elemental_vacancies;$/;"	m	struct:material
target_depth_implanted_recoils_int	material.h	/^    int **target_depth_implanted_recoils_int;$/;"	m	struct:material
target_depth_implanted_recoils_repl	material.h	/^    int **target_depth_implanted_recoils_repl;$/;"	m	struct:material
target_elemental_disp	material.h	/^    int **target_elemental_disp;         \/* displacements of this element that took place *\/$/;"	m	struct:material
target_elemental_vacancies	material.h	/^    int **target_elemental_vacancies;    \/* vacancies of this element left behind *\/$/;"	m	struct:material
target_implanted_recoils_int	material.h	/^    int **target_implanted_recoils_int;   \/* the implanted recoils stopped as interstitials *\/$/;"	m	struct:material
target_implanted_recoils_repl	material.h	/^    int **target_implanted_recoils_repl;  \/* the implanted recoils stopped as replacement atoms *\/$/;"	m	struct:material
target_sputtered_atoms	material.h	/^    int **target_sputtered_atoms;        \/* number of atoms sputtered from this cell *\/$/;"	m	struct:material
H	matrix.c	/^double H (double u, double x0, double epsilon, double s) {$/;"	f
HEADERSIZE	matrix.c	27;"	d	file:
NSUM	matrix.c	21;"	d	file:
NSUM2	matrix.c	22;"	d	file:
PHI	matrix.c	/^double (*PHI) (double x);$/;"	v
THETAERR	matrix.c	24;"	d	file:
cal_theta	matrix.c	/^double cal_theta (double epsilon, double s, unsigned int nsum) {$/;"	f
calc_matrix	matrix.c	/^int calc_matrix (unsigned int screening_type, int show_progress, char *file_name) {$/;"	f
fill_cos_sin_table	matrix.c	/^void fill_cos_sin_table (float *cos_table, float *sin_table, float mr) {$/;"	f
find_x0	matrix.c	/^double find_x0 (double epsilon, double s) {$/;"	f
finds	matrix.c	/^double finds (double epsilon, double thetaCM) {$/;"	f
func_x0	matrix.c	/^double func_x0 (double x0, double epsilon, double s) {$/;"	f
headerRef	matrix.c	/^float headerRef[HEADERSIZE] = {MINE, DIME, MAXE, MINS, DIMS, MAXS, NSUM};$/;"	v
load_matrix	matrix.c	/^int load_matrix (char file_name[]) {$/;"	f
matrix	matrix.c	/^float matrix[DIME*DIMS];$/;"	v
matrix_i	matrix.c	/^float matrix_i (unsigned long i) {$/;"	f
phi_LJ	matrix.c	/^double phi_LJ (double x) {$/;"	f
phi_none	matrix.c	/^double phi_none (double x) {$/;"	f
phi_univ	matrix.c	/^double phi_univ (double x) {$/;"	f
prepare_scattering_matrix	matrix.c	/^int prepare_scattering_matrix (struct scattering_matrix *scat_matrix, float proj_M,$/;"	f
set_matrix	matrix.c	/^void set_matrix (unsigned long i, float val) {$/;"	f
MATRIX_H	matrix.h	16;"	d
MAX_ELEMENT_NO	matrix.h	41;"	d
cos_scat	matrix.h	/^    float *cos_scat;             \/* cosines of scattering angles, for each energy and p *\/$/;"	m	struct:scattering_matrix
inv_screening_length	matrix.h	/^    float inv_screening_length;  \/* 1\/screening length in 1\/nm *\/$/;"	m	struct:scattering_matrix
ion_scattering_matrix	matrix.h	/^struct scattering_matrix ion_scattering_matrix[MAX_ELEMENT_NO];$/;"	v	typeref:struct:scattering_matrix
kfactor_m	matrix.h	/^    float kfactor_m;             \/* mass part of the kinematic factor.$/;"	m	struct:scattering_matrix
mass_ratio	matrix.h	/^    float mass_ratio;            \/* ... *\/$/;"	m	struct:scattering_matrix
red_E_conv	matrix.h	/^    float red_E_conv;            \/* reduced energy conversion factor. This is called FI in TRIM *\/$/;"	m	struct:scattering_matrix
scattering_matrices	matrix.h	/^struct scattering_matrix scattering_matrices[MAX_ELEMENT_NO][MAX_ELEMENT_NO];$/;"	v	typeref:struct:scattering_matrix
scattering_matrix	matrix.h	/^struct scattering_matrix  \/* This structure holds information for a scattering events of two$/;"	s
screening_length	matrix.h	/^    float screening_length;      \/* screening length from ZBL85,p45, eq.2-60, but in [nm] *\/$/;"	m	struct:scattering_matrix
sin_scat	matrix.h	/^    float *sin_scat;             \/* sines of scattering angles, for each energy and p *\/$/;"	m	struct:scattering_matrix
sqrt_mass_ratio	matrix.h	/^    float sqrt_mass_ratio;       \/* we will need this occasionally *\/$/;"	m	struct:scattering_matrix
mpi_distribute	mpimod.c	/^void mpi_distribute (void) {$/;"	f
mpi_init_array	mpimod.c	/^int mpi_init_array (void) {$/;"	f
mpi_reduce_data	mpimod.c	/^void mpi_reduce_data (void) {$/;"	f
mpi_seed	mpimod.c	/^int mpi_seed (int seed) {$/;"	f
MAX_EL_PER_MAT	mpimod.h	26;"	d
MAX_SPUTTERED	mpimod.h	25;"	d
MPIMOD_H	mpimod.h	13;"	d
MPI_PRALLEL	mpimod.h	21;"	d
ROOT	mpimod.h	23;"	d
ierr	mpimod.h	/^int ierr;$/;"	v
max_no_ions_node	mpimod.h	/^int max_no_ions_node;  \/* ion num per node *\/$/;"	v
my_node	mpimod.h	/^int my_node, num_nodes;$/;"	v
num_nodes	mpimod.h	/^int my_node, num_nodes;$/;"	v
reduce_double_data	mpimod.h	/^double *reduce_double_data;$/;"	v
reduce_int_data	mpimod.h	/^int    *reduce_int_data;$/;"	v
reduce_int_data2	mpimod.h	/^int     reduce_int_data2[8];$/;"	v
reduce_int_data3	mpimod.h	/^int     reduce_int_data3[MAX_SPUTTERED+1];$/;"	v
reduce_int_data4	mpimod.h	/^int     reduce_int_data4[MAX_EL_PER_MAT*8];$/;"	v
compute_lists	random.c	/^void compute_lists (void) {$/;"	f
randomize_list	random.c	/^void randomize_list (float *list, unsigned int max_list) {$/;"	f
randomx	random.c	/^double randomx (void) {$/;"	f
MAXAZILIST	random.h	31;"	d
MAXLOGLIST	random.h	30;"	d
MAXRANLIST	random.h	32;"	d
RANDOM_H	random.h	15;"	d
cos_azim_angle	random.h	/^float cos_azim_angle[MAXAZILIST];$/;"	v
gauss_random_list	random.h	/^float gauss_random_list[MAXRANLIST];  \/* Gauss distribution randomlist, ygli *\/$/;"	v
inv_sqrt_log_list	random.h	/^float inv_sqrt_log_list[MAXLOGLIST];  \/* 1\/sqrtloglist *\/$/;"	v
log_list	random.h	/^float log_list[MAXLOGLIST];  \/* important modification, sqrt_log_list -> log_list *\/$/;"	v
random_list	random.h	/^float random_list[MAXRANLIST];$/;"	v
seed1	random.h	/^int seed1, seed2;$/;"	v
seed2	random.h	/^int seed1, seed2;$/;"	v
sin_azim_angle	random.h	/^float sin_azim_angle[MAXAZILIST];  \/* list cos and sin components of angles... *\/$/;"	v
sqrt_random_list	random.h	/^float sqrt_random_list[MAXRANLIST];   \/* sqrt of randomlist *\/$/;"	v
cal_relative_target_atom_position	target.c	/^void cal_relative_target_atom_position (double vx, double vy, double vz, double *px,$/;"	f
get_cell_index	target.c	/^int get_cell_index (double x, double y, double z, int *cell_i) {$/;"	f
get_relative_XYZ	target.c	/^void get_relative_XYZ (int x, int y, int z, float *rx, float *ry, float *rz) {$/;"	f
get_target_XYZ	target.c	/^void get_target_XYZ (int index, int *x, int *y, int *z) {$/;"	f
get_target_index	target.c	/^int get_target_index (int x, int y, int z) {$/;"	f
init_target_structure	target.c	/^int init_target_structure (char *file_name) {$/;"	f
read_target_structure_data	target.c	/^int read_target_structure_data (char *par_name, char *par_value) {$/;"	f
read_target_structure_data_block	target.c	/^int read_target_structure_data_block (char *block_name) {$/;"	f
MAX_STOPPING_ENTRIES	target.h	54;"	d
TARGET_H	target.h	15;"	d
TargetCompositionFileName	target.h	/^char *TargetCompositionFileName;$/;"	v
box_start_x0	target.h	/^float box_start_x0;    \/* fetm box start point *\/$/;"	v
box_start_y0	target.h	/^float box_start_y0;$/;"	v
box_start_z0	target.h	/^float box_start_z0;$/;"	v
cell_count	target.h	/^int cell_count;        \/* total number of cells *\/$/;"	v
cell_count_x	target.h	/^int cell_count_x;      \/* number of cells in x-direction (>=1) *\/$/;"	v
cell_count_y	target.h	/^int cell_count_y;      \/* number of cells in y-direction (>=1) *\/$/;"	v
cell_count_z	target.h	/^int cell_count_z;      \/* number of cells in z-direction (>=1) *\/$/;"	v
cell_size_x	target.h	/^float cell_size_x;     \/* size of cells in x-direction in nm *\/$/;"	v
cell_size_y	target.h	/^float cell_size_y;     \/* size of cells in y-direction in nm *\/$/;"	v
cell_size_z	target.h	/^float cell_size_z;     \/* size of cells in z-direction in nm *\/$/;"	v
cell_volume	target.h	/^float cell_volume;     \/* product of the above three *\/$/;"	v
gen_shape_or_not	target.h	/^int gen_shape_or_not;  \/* 1 - generate fetm shape file for fetm geometry *\/$/;"	v
geometry_type	target.h	/^int geometry_type;     \/* 0 - CSG, 1 - FETM *\/$/;"	v
layer_count_yz	target.h	/^int layer_count_yz;    \/* layer_count_xy = cell_count_x * cell_count_y,$/;"	v
sub_surf_z	target.h	/^float sub_surf_z;      \/* z coordinate of the half-infinite substrate surface in nm *\/$/;"	v
target_composition	target.h	/^int   *target_composition;          \/* material of each cell *\/$/;"	v
target_composition_file_type	target.h	/^int target_composition_file_type;   \/* The file which hold the info of what material is in$/;"	v
target_depth_energy_electrons	target.h	/^double *target_depth_energy_electrons;$/;"	v
target_depth_energy_phonons	target.h	/^double *target_depth_energy_phonons;$/;"	v
target_depth_implanted_ions	target.h	/^int   *target_depth_implanted_ions;$/;"	v
target_depth_replacing_ions	target.h	/^int   *target_depth_replacing_ions;$/;"	v
target_depth_total_displacements	target.h	/^int   *target_depth_total_displacements;$/;"	v
target_depth_total_interstitials	target.h	/^int   *target_depth_total_interstitials;$/;"	v
target_depth_total_replacements	target.h	/^int   *target_depth_total_replacements;$/;"	v
target_depth_total_vacancies	target.h	/^int   *target_depth_total_vacancies;$/;"	v
target_energy_electrons	target.h	/^double *target_energy_electrons;    \/* all energy deposited by electronic stopping.$/;"	v
target_energy_phonons	target.h	/^double *target_energy_phonons;      \/* all energy deposited into the phononic system *\/$/;"	v
target_implanted_ions	target.h	/^int   *target_implanted_ions;       \/* implanted ions per cell (interstitials+replacements) *\/$/;"	v
target_max_x	target.h	/^float target_max_x;    \/* maximum allowed position in x-direction in nm *\/$/;"	v
target_max_y	target.h	/^float target_max_y;    \/* these positions are the largest possible values, *\/$/;"	v
target_max_z	target.h	/^float target_max_z;    \/* which are smaller target_size_x etc. *\/$/;"	v
target_replacing_ions	target.h	/^int   *target_replacing_ions;       \/* implanted ions that replaced identical target atoms *\/$/;"	v
target_size_x	target.h	/^float target_size_x;   \/* size of target in x-direction in nm *\/$/;"	v
target_size_y	target.h	/^float target_size_y;   \/* they are calculated *\/$/;"	v
target_size_z	target.h	/^float target_size_z;$/;"	v
target_total_displacements	target.h	/^int   *target_total_displacements;  \/* displacements per cell (of all types) *\/ \/* Disp = Vac + Repl *\/$/;"	v
target_total_interstitials	target.h	/^int   *target_total_interstitials;  \/* sum of interstitials per cell (of all recoil$/;"	v
target_total_replacements	target.h	/^int   *target_total_replacements;   \/* replacements per cell (of all types) *\/$/;"	v
target_total_sputtered	target.h	/^int  *target_total_sputtered;       \/* sum of sputtered atoms from each cell *\/$/;"	v
target_total_vacancies	target.h	/^int   *target_total_vacancies;      \/* vacancies per cell (of all types) *\/$/;"	v
total_sputter_counter	target.h	/^int total_sputter_counter[8];       \/* number of target atoms leaving the sample in each of the$/;"	v
use_density_mult	target.h	/^int   use_density_mult;             \/* 0 if multiplicators not used, 1 if used *\/$/;"	v
coll_c	transport.c	/^int coll_c;             \/* collide *\/$/;"	v
collision	transport.c	/^int collision (int projZ, float projM, int is_ion, float *energy, double target_x,$/;"	f
def_ion_enetry_pos	transport.c	/^void def_ion_enetry_pos (double *x, double *y, double *z) {$/;"	f
disp_c	transport.c	/^int disp_c;             \/* dispalcement *\/$/;"	v
e_energy_loss	transport.c	/^void e_energy_loss (int projZ, int projM, float projE, int mater_type, double s,$/;"	f
escape_solid_c	transport.c	/^int escape_solid_c;     \/* *\/$/;"	v
int_c	transport.c	/^int int_c;              \/* interstitial *\/$/;"	v
ion_c	transport.c	/^int ion_c;              \/* ion *\/$/;"	v
irradiate_target	transport.c	/^int irradiate_target (void) {$/;"	f
leaving_ions_c	transport.c	/^int leaving_ions_c;     \/* *\/$/;"	v
leaving_recoils_c	transport.c	/^int leaving_recoils_c;  \/* *\/$/;"	v
miss_c	transport.c	/^int miss_c;             \/* missed collision *\/$/;"	v
projectile_transport	transport.c	/^int projectile_transport (int projZ, float projM, float projE, double proj_x,$/;"	f
refract_projectile2	transport.c	/^int refract_projectile2 (double *vx, double *vy, double *vz, double nx, double ny,$/;"	f
repl_c	transport.c	/^int repl_c;             \/* replacement *\/$/;"	v
rotate	transport.c	/^void rotate (double *l, double *m, double *n, unsigned int *iazim_angle,$/;"	f
single_ion_sputter_counter	transport.c	/^int single_ion_sputter_counter;$/;"	v
sputter_c	transport.c	/^int sputter_c;          \/* sputtering *\/$/;"	v
update_xyz	transport.c	/^void update_xyz (double *x, double *y, double *z, double vx, double vy, double vz, double s) {$/;"	f
vac_c	transport.c	/^int vac_c;              \/* vacancy *\/$/;"	v
MAX_SPUTTERED	transport.h	137;"	d
TRANSPORT_H	transport.h	15;"	d
beam_spread	transport.h	/^float beam_spread;           \/* in nm, only relevant for option 3 *\/$/;"	v
chu_values	transport.h	/^float chu_values[98][4];    \/* Values to calculate straggling according to Chu's model;$/;"	v
detailed_sputtering	transport.h	/^int detailed_sputtering;  \/* Needs to be set to 1, if you want to get better results regarding$/;"	v
display_interval	transport.h	/^int    display_interval;        \/* display status every so many ions *\/$/;"	v
energy	transport.h	/^    float  energy;            \/* exit energy *\/$/;"	m	struct:transmitted_ion
enter_x	transport.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_y	transport.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
enter_z	transport.h	/^float enter_x, enter_y, enter_z;      \/* entry point in nm *\/$/;"	v
flight_length_const	transport.h	/^float flight_length_const;  \/* If constant flight length is selected, then this is it (in nm). *\/$/;"	v
flight_length_type	transport.h	/^int flight_length_type;    \/* Flight lengths between collisions can be selected by three$/;"	v
ion_M	transport.h	/^float ion_M;                  \/* mass of the ion *\/$/;"	v
ion_Z	transport.h	/^int   ion_Z;                  \/* proton number *\/$/;"	v
ion_distribution	transport.h	/^int   ion_distribution;      \/* 0 for random ion entry positions,$/;"	v
ion_initial_energy	transport.h	/^float ion_initial_energy;     \/* impinging energy *\/$/;"	v
ion_paths_fp	transport.h	/^FILE *ion_paths_fp;         \/* the file with the ion paths will be open all the time if the paths$/;"	v
ion_vx	transport.h	/^float ion_vx;                \/* vector of ion velocity, normalized to 1 *\/$/;"	v
ion_vy	transport.h	/^float ion_vy;                \/* Note, that the ion is NOT described by its actual velocity vector, *\/$/;"	v
ion_vz	transport.h	/^float ion_vz;                \/* but by the flying direction vector of length 1 and its energy. *\/$/;"	v
leaving_ions	transport.h	/^int leaving_ions[8];        \/* number of ions, leaving target in each direction\/quadrants, ygli *\/$/;"	v
max_annular_coll_volumes	transport.h	/^int max_annular_coll_volumes;  \/* According to W.Eckstein "Computer Simulation if Ion-Solid$/;"	v
max_no_ions	transport.h	/^int   max_no_ions;            \/* maximum number of ions *\/$/;"	v
min_energy	transport.h	/^float min_energy;            \/* minimum energy below which all projectiles are stopped *\/$/;"	v
override_energy	transport.h	/^float  override_energy;         \/* for command-line argument override of ion energy *\/$/;"	v
override_max_ions	transport.h	/^int    override_max_ions;       \/* for command-line argument override of maximum number of ions *\/$/;"	v
recoil_cascades_fp	transport.h	/^FILE *recoil_cascades_fp;   \/* the file with the recoil cascades will be open all the time if the$/;"	v
scattering_calculation	transport.h	/^int scattering_calculation;     \/* 0: corteo database, 1: MAGIC  *\/$/;"	v
simulation_type	transport.h	/^int simulation_type;  \/* How to do the simulation.$/;"	v
single_ion_sputter_yields	transport.h	/^int single_ion_sputter_yields;  \/* if 1, iradina will store sputter yields for single ions$/;"	v
sputter_yield_histogram	transport.h	/^int *sputter_yield_histogram;   \/* array that stores single ion sputter yield histogram *\/$/;"	v
status_update_interval	transport.h	/^int    status_update_interval;  \/* After so many ions, the status is written to the status file$/;"	v
storage_interval	transport.h	/^int    storage_interval;        \/* dump the target arrays into the files every such number of ions *\/$/;"	v
store_energy_deposit	transport.h	/^int store_energy_deposit;  \/* if 1, array with deposited energy are created and stored;$/;"	v
store_exiting_limit	transport.h	/^int store_exiting_limit;     \/* maximum number of exiting recoils to be stored *\/$/;"	v
store_exiting_recoils	transport.h	/^int store_exiting_recoils;   \/* 1 if all exiting recoils should be stored *\/$/;"	v
store_ion_paths	transport.h	/^int store_ion_paths;  \/* 1 if the exact paths should be stored (interesting for debugging stuff *\/$/;"	v
store_path_limit	transport.h	/^int store_path_limit;        \/* only for so many ions, the exact paths and recoil cascades are stored *\/$/;"	v
store_recoil_cascades	transport.h	/^int store_recoil_cascades;  \/* 1 if the exact recoils cascades should be stored$/;"	v
store_transmitted_ions	transport.h	/^int store_transmitted_ions;  \/* 1 if true *\/$/;"	v
straggling_model	transport.h	/^int straggling_model;       \/* how to calc straggling *\/$/;"	v
transmission_pointer	transport.h	/^int transmission_pointer;    \/* point to next free index in array *\/$/;"	v
transmit_list	transport.h	/^struct transmitted_ion *transmit_list;  \/* list of transmitted ions *\/$/;"	v	typeref:struct:transmitted_ion
transmitted_ion	transport.h	/^struct transmitted_ion       \/* describes an ion that has been transmitted (left the target) *\/$/;"	s
transport_type	transport.h	/^int transport_type;             \/* 0: accurate, 1: Fast (like corteo) *\/$/;"	v
vx	transport.h	/^    double vx;                \/* exit velocity unit vector *\/$/;"	m	struct:transmitted_ion
vy	transport.h	/^    double vy;$/;"	m	struct:transmitted_ion
vz	transport.h	/^    double vz;$/;"	m	struct:transmitted_ion
x	transport.h	/^    double x;                 \/* exit position x *\/$/;"	m	struct:transmitted_ion
y	transport.h	/^    double y;                 \/* y *\/$/;"	m	struct:transmitted_ion
z	transport.h	/^    double z;                 \/* z *\/$/;"	m	struct:transmitted_ion
cal_direct	triangulate.c	/^void cal_direct (double xyz[], double *sin_theta, double *cos_theta,$/;"	f
generate_fetm_tri_shape	triangulate.c	/^int generate_fetm_tri_shape (void) {$/;"	f
make_line_tri	triangulate.c	/^void make_line_tri (int flag_or_not, double sin_theta, double cos_theta,$/;"	f
read_file_opengl	triangulate.c	/^int read_file_opengl (int n, int num_of_data) {$/;"	f
read_file_ply2	triangulate.c	/^int read_file_ply2 (int n) {$/;"	f
TRIANGULATE_H	triangulate.h	15;"	d
file_format	triangulate.h	/^int file_format;  \/* all list in Config.in *\/$/;"	v
material	triangulate.h	/^int material[20];$/;"	v
num_of_data	triangulate.h	/^int num_of_data[20];$/;"	v
num_of_material	triangulate.h	/^int num_of_material;$/;"	v
scaling_x	triangulate.h	/^double scaling_x, scaling_y, scaling_z;$/;"	v
scaling_y	triangulate.h	/^double scaling_x, scaling_y, scaling_z;$/;"	v
scaling_z	triangulate.h	/^double scaling_x, scaling_y, scaling_z;$/;"	v
triangle	triangulate.h	/^double **triangle;$/;"	v
xyz_flag	triangulate.h	/^double xyz_flag;$/;"	v
a2f	utils.c	/^float a2f (char *s) {$/;"	f
add_int_array	utils.c	/^void add_int_array (int *dest, int *source, int count) {$/;"	f
calculate_normalization_factor	utils.c	/^void calculate_normalization_factor (int num_of_ions) {$/;"	f
copy_double_array	utils.c	/^ double copy_double_array (double a[], double b[], int num_elements) {$/;"	f
copy_int_array	utils.c	/^ int copy_int_array (int a[], int b[], int num_elements) {$/;"	f
cross_product	utils.c	/^void cross_product (double a[], double b[], double c[]) {$/;"	f
d2f	utils.c	/^float d2f (double val) {$/;"	f
dot_product	utils.c	/^double dot_product (double a[], double b[]) {$/;"	f
fast_sqrt	utils.c	/^float fast_sqrt (float val) {$/;"	f
fill_double_zero	utils.c	/^void fill_double_zero (double *array, int count) {$/;"	f
fill_int_zero	utils.c	/^void fill_int_zero (int *array, int count) {$/;"	f
get_float_one_bit_smaller	utils.c	/^void get_float_one_bit_smaller (float *flt_input, float *flt_output) {$/;"	f
get_leaving_direction	utils.c	/^int get_leaving_direction (double vx, double vy, double vz) {$/;"	f
handle_cmd_line_options	utils.c	/^int handle_cmd_line_options (int argc, char *argv[]) {$/;"	f
ignoreline	utils.c	/^void ignoreline (FILE *ifp) {$/;"	f
inv_sqrt	utils.c	/^float inv_sqrt (float val) {$/;"	f
make_float_array	utils.c	/^int make_float_array (char *values, int count, float *f_array) {$/;"	f
make_int_array	utils.c	/^int make_int_array (char *values, int count, int *i_array) {$/;"	f
mat_mul	utils.c	/^void mat_mul (double a[], double b[], int m, int n, int k, double c[]) {$/;"	f
max_loc_abs	utils.c	/^int max_loc_abs (double a[], int n) {$/;"	f
print_help_text	utils.c	/^int print_help_text (void) {$/;"	f
sqrtdf	utils.c	/^float sqrtdf (double val) {$/;"	f
sum_array	utils.c	/^ double sum_array (double a[], int num_elements) {$/;"	f
write_status_file	utils.c	/^int write_status_file (char *status_text, int ion_number) {$/;"	f
MAX	utils.h	42;"	d
UTILS_H	utils.h	15;"	d
conv_create_separate_elements	utils.h	/^int conv_create_separate_elements;$/;"	v
